// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{ template }}

// Tests contained in this file are not exhaustive.
// We'll use tc39/test262 eventually.

use assert_matches::assert_matches;
use base::macros::assert_eq;
use jsruntime::Runtime;
use jsruntime::Value;

logging::init!();

#[ctor::ctor]
fn init_jsruntime() {
    jsruntime::initialize();
}

struct Validator {
    expected_values: Vec<Value>,
    actual_values: Vec<Value>,
}

impl Drop for Validator {
    fn drop(&mut self) {
        assert_eq!(self.actual_values.len(), self.expected_values.len());
        for (actual, expected) in self.actual_values.iter().zip(self.expected_values.iter()) {
            // Some cases including `f64::NAN` fail in `assert_eq!()`.
            let actual = format!("{actual:?}");
            let expected = format!("{expected:?}");
            assert_eq!(actual, expected);
        }
    }
}

fn evaluate(src: &str, optimize: bool, expected_values: Vec<Value>) -> Result<Value, Value> {
    let mut runtime = Runtime::with_extension(Validator {
        expected_values,
        actual_values: vec![],
    });
    runtime.enable_scope_cleanup_checker();
    runtime.register_host_function("print", |runtime, args| {
        runtime.extension_mut().actual_values.push(args[0].clone());
    });
    let program = runtime.parse_script(src).unwrap();
    let module = runtime.compile(&program, optimize).unwrap();
    runtime.evaluate(module)
}
{%- for test in data.tests %}

#[test]
fn {{ test.name }}_optimize() {
   {{ test.name }}(true);
}

#[test]
fn {{ test.name }}_no_optimize() {
   {{ test.name }}(false);
}

fn {{ test.name }}(optimize: bool) {
    let src = include_str!("{{ test.name }}.js");
    let result = evaluate(src, optimize, vec![
        {%- for expected in test.expectedValues %}
        Value::from({{ expected }}),
        {%- endfor %}
    ]);
    {%- if test.throws %}
    assert_matches!(result, Err(actual) => {
        // Some cases including `f64::NAN` fail in `assert_eq!()`.
        let actual = format!("{actual:?}");
        let expected = format!("{:?}", Value::from({{ test.throws }}));
        assert_eq!(actual, expected);
    });
    {%- else %}
    assert_matches!(result, Ok(_));
    {%- endif %}
}
{%- endfor %}
