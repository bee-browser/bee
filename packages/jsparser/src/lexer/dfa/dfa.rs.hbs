// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated by:
// {{@command}}

use super::SourceCursor;
use super::Token;
use super::TokenKind;

pub fn recognize<'a>(cursor: &SourceCursor<'a>) -> Token<'a> {
    let mut token = Token::default();

    let mut state = State::default();
    tracing::trace!(opcode = "init", ?state);

    let mut lexeme_end = 0;
    let mut chars = cursor.chars();
    loop {
        let (pos, unicode_set) = match chars.next() {
            Some((i, ch)) => (cursor.pos() + i, UnicodeSet::from(ch)),
            None => (cursor.len(), UnicodeSet::EOF),
        };

        state = state.next_state(&unicode_set);
        tracing::trace!(opcode = "next", ?state, ?unicode_set, pos);
        if state.is_invalid() {
            break;
        }
        if !state.lookahead() {
            //debug_assert_eq!(lexeme_end, i);
            lexeme_end = pos + match unicode_set.1 {
                Some(ch) => ch.len_utf8(),
                None => 0,
            };
        }
        if let Some(kind) = state.accept() {
            token.kind = kind;
            token.lexeme = cursor.lexeme(lexeme_end - cursor.pos());
            tracing::trace!(opcode = "accept", ?token.kind, ?token.lexeme);
        }
    }

    token
}

#[derive(Clone, Copy, Debug)]
struct UnicodeSet(u8, Option<char>);

impl UnicodeSet {
    const EOF: Self = UnicodeSet({{length unicodeSets}}, None);
}

impl From<char> for UnicodeSet {
    fn from(ch: char) -> Self {
        let c = ch as usize;
        if c < 128 {
            return UnicodeSet(ASCII_TABLE[c], Some(ch));
        }
        {{#each nonAsciiList}}
        {{#if span}}
        if c >= {{firstCodePoint}} && c <= {{lastCodePoint}} {
            return UnicodeSet({{unicodeSet}}, Some(ch));
        }
        {{else}}
        if c == {{firstCodePoint}} {
            return UnicodeSet({{unicodeSet}}, Some(ch));
        }
        {{/if}}
        {{/each}}
        UnicodeSet({{length unicodeSets}}, Some(ch))
    }
}

const ASCII_TABLE: [u8; 128] = {{json asciiTable}};

#[derive(Clone, Copy, Debug, Default)]
struct State(u16);

impl State {
    #[inline(always)]
    fn is_invalid(&self) -> bool {
        self.0 == {{numStates}}
    }

    #[inline(always)]
    fn next_state(&self, unicode_set: &UnicodeSet) -> State {
        State(TRANSITION_TABLE[self.0 as usize][unicode_set.0 as usize])
    }

    #[inline(always)]
    fn lookahead(&self) -> bool {
        LOOKAHEAD_TABLE[self.0 as usize]
    }

    #[inline(always)]
    fn accept(&self) -> Option<TokenKind> {
        ACCEPT_TABLE[self.0 as usize]
    }
}

const TRANSITION_TABLE: [[u16; {{numTransitions}}]; {{numStates}}] = [
    {{#each states}}
    // State({{@index}}):
    {{#each labels}}
    //   {{this}}
    {{/each}}
    {{#if transitionLabels}}
    // Transitions:
    {{#each transitionLabels}}
    //   {{this}}
    {{/each}}
    {{/if}}
    {{json transitions}},
    {{/each}}
];

const ACCEPT_TABLE: [Option<TokenKind>; {{numStates}}] = [
    {{#each states}}
    {{#if accept}}
    Some(TokenKind::{{pascalCase accept}}), // State({{@index}})
    {{else}}
    None, // State({{@index}})
    {{/if}}
    {{/each}}
];

const LOOKAHEAD_TABLE: [bool; {{numStates}}] = [
    {{#each states}}
    {{#if lookahead}}
    true, // State({{@index}})
    {{else}}
    false, // State({{@index}})
    {{/if}}
    {{/each}}
];
