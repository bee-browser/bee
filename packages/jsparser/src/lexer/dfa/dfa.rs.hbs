// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated by:
// {{@command}}

use super::SourceCursor;
use super::Token;
use super::TokenKind;

pub fn recognize<'a>(cursor: &SourceCursor<'a>) -> Token<'a> {
    let mut cursor = cursor.clone();

    let mut token = Token::default();
    let mut state = State::default();
    tracing::trace!(opcode = "state", ?state);

    while let Some(ch) = cursor.get() {
        tracing::trace!(opcode = "char", char = ?ch);
        let unicode_set = match UnicodeSet::try_from(ch) {
            Ok(unicode_set) => unicode_set,
            Err(_) => break,
        };
        tracing::trace!(opcode = "unicode-set", ?unicode_set);
        state = state.next_state(unicode_set);
        tracing::trace!(opcode = "state", ?state);
        if state.is_invalid() {
            break;
        }
        if state.lookahead() {
            cursor.lookahead();
        } else {
            cursor.consume();
        }
        if let Some(kind) = state.accept() {
            token.kind = kind;
            token.lexeme = cursor.lexeme();
            tracing::trace!(opcode = "candidate", ?token.kind, token.lexeme);
        }
    }
    token
}

#[derive(Clone, Copy, Debug)]
struct UnicodeSet(u8);

impl TryFrom<char> for UnicodeSet {
    type Error = ();

    fn try_from(ch: char) -> Result<Self, Self::Error> {
        let c = ch as usize;
        if c < 128 {
            return Ok(UnicodeSet(ASCII_TABLE[c]));
        }
        {{#each nonAsciiList}}
        {{#if span}}
        if c >= {{firstCodePoint}} && c <= {{lastCodePoint}} {
            return Ok(UnicodeSet({{unicodeSet}}));
        }
        {{else}}
        if c == {{firstCodePoint}} {
            return Ok(UnicodeSet({{unicodeSet}}));
        }
        {{/if}}
        {{/each}}
        Err(())
    }
}

const ASCII_TABLE: [u8; 128] = {{json asciiTable}};

#[derive(Clone, Copy, Debug, Default)]
struct State(u16);

impl State {
    #[inline(always)]
    fn is_invalid(&self) -> bool {
        self.0 == {{length states}}
    }

    #[inline(always)]
    fn next_state(&self, unicode_set: UnicodeSet) -> State {
        State(TRANSITION_TABLE[self.0 as usize][unicode_set.0 as usize])
    }

    #[inline(always)]
    fn lookahead(&self) -> bool {
        LOOKAHEAD_TABLE[self.0 as usize]
    }

    #[inline(always)]
    fn accept(&self) -> Option<TokenKind> {
        ACCEPT_TABLE[self.0 as usize]
    }
}

const TRANSITION_TABLE: [[u16; {{length unicodeSets}}]; {{length states}}] = [
    {{#each states}}
    {{json transitions}},
    {{/each}}
];

const ACCEPT_TABLE: [Option<TokenKind>; {{length states}}] = [
    {{#each states}}
    {{#if accept}}
    Some(TokenKind::{{pascalCase accept}}),
    {{else}}
    None,
    {{/if}}
    {{/each}}
];

const LOOKAHEAD_TABLE: [bool; {{length states}}] = [
    {{#each states}}
    {{#if lookahead}}
    true,
    {{else}}
    false,
    {{/if}}
    {{/each}}
];
