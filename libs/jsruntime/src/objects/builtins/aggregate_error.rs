// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: libs/jsruntime/src/objects/builtins/native_error.rs.njk

use jsparser::Symbol;

use crate::Runtime;
use crate::logger;
use crate::objects::ObjectHandle;
use crate::objects::Property;
use crate::types::CallContext;
use crate::types::Status;
use crate::types::StringHandle;
use crate::types::Value;

impl<X> Runtime<X> {
    pub(super) fn create_aggregate_error_constructor(&mut self) -> ObjectHandle {
        logger::debug!(event = "create_aggregate_error_constructor");
        debug_assert!(self.aggregate_error_prototype.is_some());
        let constructor =
            self.create_builtin_function(constructor::<X>, self.aggregate_error_prototype);
        if let Some(mut prototype) = self.aggregate_error_prototype {
            let _ = prototype.define_own_property(
                Symbol::CONSTRUCTOR.into(),
                Property::data_xxx(Value::Object(constructor)),
            );
        }
        constructor
    }

    pub(super) fn create_aggregate_error_prototype(&mut self) -> ObjectHandle {
        logger::debug!(event = "creater_aggregate_error_prototype");
        debug_assert!(self.error_prototype.is_some());

        let mut prototype = self.create_object(self.error_prototype);
        let _ = prototype.define_own_property(
            Symbol::MESSAGE.into(),
            Property::data_xxx(Value::String(StringHandle::EMPTY)),
        );
        let _ = prototype.define_own_property(
            Symbol::NAME.into(),
            Property::data_xxx(Value::String(const_string!(
                jsparser::symbol::builtin::names::AGGREGATE_ERROR
            ))),
        );

        prototype
    }

    pub(crate) fn create_aggregate_error(
        &mut self,
        new: bool,
        message: &Value,
        options: &Value,
    ) -> Result<ObjectHandle, Value> {
        logger::debug!(event = "create_aggregate_error", new, ?message, ?options);
        // TODO(feat): NewTarget
        let mut object = self.create_object(self.aggregate_error_prototype);

        object.set_error();

        match message {
            Value::Undefined => (),
            _ => {
                let msg = self.perform_to_string(message);
                // TODO: error handling
                let _ = object.define_own_property(
                    Symbol::MESSAGE.into(),
                    Property::data_wxc(Value::String(msg)),
                );
            }
        }

        if let Value::Object(value) = options {
            let key = Symbol::CAUSE.into();
            if let Some(value) = value.get_value(&key) {
                // TODO: error handling
                let _ = object.define_own_property(key, Property::data_wxc(value.clone()));
            }
        }

        Ok(object)
    }
}

// lambda functions

extern "C" fn constructor<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    let new = context.is_new();
    let args = context.args();
    let message = args.first().unwrap_or(&Value::Undefined);
    let options = args.get(1).unwrap_or(&Value::Undefined);
    match runtime.create_aggregate_error(new, message, options) {
        Ok(value) => {
            *retv = Value::Object(value);
            Status::Normal
        }
        Err(value) => {
            *retv = value;
            Status::Exception
        }
    }
}
