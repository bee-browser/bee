// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: mod.rs.mustache

mod imp;

use jsparser::Symbol;

use crate::Runtime;
use crate::logger;
use crate::objects::ObjectHandle;
use crate::objects::Property;
use crate::types::CallContext;
use crate::types::Status;
use crate::types::Value;

impl<X> Runtime<X> {
    /// Returns `true` if `object` is a Promise object.
    pub fn is_promise_object(&self, object: ObjectHandle) -> bool {
        object.is_instance_of(self.promise_prototype)
    }

    /// Returns `true` if `value` holds a Promise object.
    pub fn value_is_promise_object(&self, value: &Value) -> bool {
        matches!(value, Value::Object(object) if self.is_promise_object(*object))
    }
    {{#constructorProperties}}

    pub(super) fn create_promise_constructor(&mut self) -> ObjectHandle {
        logger::debug!(event = "create_promise_constructor");
        debug_assert!(self.promise_prototype.is_some());

        let mut constructor = self.create_builtin_function(constructor, self.promise_prototype);

        {{#functions}}
        let mut func = self.create_builtin_function({{{imp}}}, None);
        let _ = func.define_own_property(Symbol::NAME.into(), Property::data_xxc(Value::String(const_string!("{{{name}}}"))));
        let _ = func.define_own_property(Symbol::LENGTH.into(), Property::data_xxc(Value::Number({{{length}}}.0)));
        let _ = constructor.define_own_property(Symbol::{{{symbol}}}.into(), Property::data_wxc(Value::Object(func)));

        {{/functions}}
        // TODO(refactor): bind outside this function
        if let Some(mut prototype) = self.promise_prototype {
            let _ = prototype.define_own_property(Symbol::CONSTRUCTOR.into(), Property::data_wxc(Value::Object(constructor)));
        }

        constructor
    }
    {{/constructorProperties}}
    {{#prototypeProperties}}

    pub(super) fn create_promise_prototype(&mut self) -> ObjectHandle {
        logger::debug!(event = "creater_promise_prototype");
        debug_assert!(self.object_prototype.is_some());
        debug_assert!(self.function_prototype.is_some());

        let mut prototype = self.create_object(self.object_prototype);

        {{#functions}}
        let mut func = self.create_builtin_function({{{imp}}}, None);
        let _ = func.define_own_property(Symbol::NAME.into(), Property::data_xxc(Value::String(const_string!("{{{name}}}"))));
        let _ = func.define_own_property(Symbol::LENGTH.into(), Property::data_xxc(Value::Number({{{length}}}.0)));
        let _ = prototype.define_own_property(Symbol::{{{symbol}}}.into(), Property::data_wxc(Value::Object(func)));

        {{/functions}}
        prototype
    }
    {{/prototypeProperties}}
}

// lambda functions

extern "C" fn constructor<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::promise(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{#constructorProperties.functions}}

extern "C" fn {{imp}}<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::{{imp}}(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{/constructorProperties.functions}}
{{#prototypeProperties.functions}}

extern "C" fn {{imp}}<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::{{imp}}(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{/prototypeProperties.functions}}
