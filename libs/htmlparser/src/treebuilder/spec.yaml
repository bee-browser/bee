html5-spec:
  # You can create the permalink to the description of each insertion mode with
  # the following format:
  #
  #   ${html5-spec.url}/commit-snapshots/${html5-spec.version}/#${modes[].ref}
  #
  url: https://html.spec.whatwg.org
  # Change the commit-hash if you update this file based on another version.
  version: 4ca6ec020803cbdfd05f90475b6e3a3a0d5b2424

# Manually converted definitions of tree construction rules.
# Almost all rules are the same as ones defined in the HTML5 specification.
#
# * The guard condition in the rule for `<noscript>` in the `in-head` insertion
#   mode is expanded inside the Rust code in the `run` property.
# * Steps of `Anything else` in the `in-table-text` are manually expanded.
modes:
  - name: initial
    ref: the-initial-insertion-mode
    rules:
      - match: whitespace
        run: |
          {{use '$ignore-token'}}
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          if let Some(name) = doctype.name {
              if name != "html" {
                  {{use '$parse-error'}}
              }
          }
          if doctype.public_id.is_some() {
              {{use '$parse-error'}}
          }
          if let Some(system_id) = doctype.system_id {
              if system_id != "about:legacy-compat" {
                  {{use '$parse-error'}}
              }
          }
          self.append_doctype(&doctype);
          self.determine_quirks_mode(&doctype);
          self.switch_to(mode!(BeforeHtml));
          Control::Continue
      - match: any
        run: |
          if !self.iframe_srcdoc {
              {{use '$parse-error'}}
          }
          self.change_quirks_mode_if_changeable(QuirksMode::Quirks);
          self.switch_to(mode!(BeforeHtml));
          Control::Reprocess

  - name: before-html
    ref: the-before-html-insertion-mode
    rules:
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: comment
        run: |
          //debug_assert!(self.writer.is_empty());
          self.insert_comment(&comment);
          Control::Continue
      - match: whitespace
        run: |
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          //debug_assert!(self.writer.is_empty());
          self.push_html_html_element(tag);
          self.switch_to(mode!(BeforeHead));
          Control::Continue
      - match: </head> </body> </html> </br>
        run: |
          {{use 'anything-else'}}
      - match: </_>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          //debug_assert!(self.writer.is_empty());
          self.push_html_html_element(&Tag::with_no_attrs("html"));
          self.switch_to(mode!(BeforeHead));
          Control::Reprocess

  - name: before-head
    ref: the-before-head-insertion-mode
    rules:
      - match: whitespace
        run: |
          {{use '$ignore-token'}}
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <head>
        run: |
          self.push_html_head_element(tag);
          self.switch_to(mode!(InHead));
          Control::Continue
      - match: </head> </body> </html> </br>
        run: |
          {{use 'anything-else'}}
      - match: </_>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          self.push_html_head_element(&Tag::with_no_attrs("head"));
          self.switch_to(mode!(InHead));
          Control::Reprocess

  - name: in-head
    ref: parsing-main-inhead
    rules:
      - match: whitespace
        run: |
          self.append_text(text.data);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <base> <basefont> <bgsound> <link>
        run: |
          self.push_html_{{tag_name}}_element(tag);
          self.pop_element();
          if tag.self_closing {
              {{use '$acknowledge-self-closing' }}
          }
          Control::Continue
      - match: <meta>
        run: |
          self.push_html_meta_element(tag);
          self.pop_element();
          if tag.self_closing {
              {{use '$acknowledge-self-closing' }}
          }
          // TODO: If the active speculative HTML parser is null
          Control::Continue
      - match: <title>
        run: |
          {{use '$generic-rcdata-element-parsing-algorithm'}}
      - match: <noscript>
        run: |
          if self.scripting {
              {{use '$generic-raw-text-element-parsing-algorithm'}}
          } else {
              self.push_html_noscript_element(tag);
              self.switch_to(mode!(InHeadNoscript));
              Control::Continue
          }
      - match: <noframes> <style>
        run: |
          {{use '$generic-raw-text-element-parsing-algorithm'}}
      - match: <script>
        run: |
          // TODO
          self.push_html_script_element(tag);
          self.save_and_switch_to(mode!(Text));
          Control::SwitchTo(InitialState::ScriptData, "script")
      - match: </head>
        run: |
          debug_assert!(self.context().is_html_element(tag!(Head)));
          self.pop_element();
          self.switch_to(mode!(AfterHead));
          Control::Continue
      - match: </body> </html> </br>
        run: |
          {{use 'anything-else'}}
      - match: <template>
        run: |
          self.push_html_template_element(tag);
          self.push_marker_to_active_formatting_contexts();
          self.context_mut().flags |= flags!(HasTemplateElement);
          self.frameset_ok = false;
          self.switch_to(mode!(InTemplate));
          self.push_template_mode(mode!(InTemplate));
          Control::Continue
      - match: </template>
        run: |
          if !self.context().has_template_element() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_all_implied_tags();
              if !self.context().is_html_element(tag!(Template)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Template)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html template element
              self.pop_active_formatting_elements_up_to_marker();
              self.pop_template_mode();
              self.reset_insertion_mode_appropriately();
              Control::Continue
          }
      - match: <head> </_>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          debug_assert!(self.context().is_html_element(tag!(Head)));
          self.pop_element();
          self.switch_to(mode!(AfterHead));
          Control::Reprocess

  - name: in-head-noscript
    ref: parsing-main-inheadnoscript
    rules:
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: </noscript>
        run: |
          debug_assert!(self.context().is_html_element(tag!(Noscript)));
          self.pop_element();
          debug_assert!(self.context().is_html_element(tag!(Head)));
          self.switch_to(mode!(InHead));
          Control::Continue
      - match: >-
          whitespace comment <basefont> <bgsound> <link> <meta> <noframes>
          <style>
        run: |
          {{use '@in-head'}}
      - match: </br>
        run: |
          {{use 'anything-else'}}
      - match: <head> <noscript> </_>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          {{use '$parse-error'}}
          debug_assert!(self.context().is_html_element(tag!(Noscript)));
          self.pop_element();
          debug_assert!(self.context().is_html_element(tag!(Head)));
          self.switch_to(mode!(InHead));
          Control::Reprocess

  - name: after-head
    ref: the-after-head-insertion-mode
    rules:
      - match: whitespace
        run: |
          self.append_text(text.data);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <body>
        run: |
          self.push_html_body_element(tag);
          self.frameset_ok = false;
          self.switch_to(mode!(InBody));
          Control::Continue
      - match: <frameset>
        run: |
          self.push_html_frameset_element(tag);
          self.switch_to(mode!(InFrameset));
          Control::Continue
      - match: >-
          <base> <basefont> <bgsound> <link> <meta> <noframes> <script> <style>
          <template> <title>
        run: |
          {{use '$parse-error'}}
          self.reopen_head_element();
          let ctrl = {
              {{use '@in-head'}}
          };
          self.close_head_element();
          ctrl
        pre_conditions:
          has_head_element_pointer: true
        post_conditions:
          has_head_element_pointer: true
      - match: </template>
        run: |
          {{use '@in-head'}}
      - match: </body> </html> </br>
        run: |
          {{use 'anything-else'}}
      - match: <head> </_>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          self.push_html_body_element(&Tag::with_no_attrs("body"));
          self.switch_to(mode!(InBody));
          Control::Reprocess

  - name: in-body
    ref: parsing-main-inbody
    rules:
      # Using `null` causes some issues.
      # So, we use `nul` as a simple solution.
      - match: nul
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: whitespace
        run: |
          self.reconstruct_active_formatting_elements();
          self.append_text(text.data);
          Control::Continue
      # text: !(nul or whitespace)
      - match: text
        run: |
          self.reconstruct_active_formatting_elements();
          self.append_text(text.data);
          self.frameset_ok = false;
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '$parse-error'}}
          if self.context().has_template_element() {
              // Ignore the token.
          } else {
              self.set_attributes_to_html_element(tag);
          }
          Control::Continue
      - match: >-
          <base> <basefont> <bgsound> <link> <meta> <noframes> <script> <style>
          <template> <title> </template>
        run: |
          {{use '@in-head'}}
      - match: <body>
        run: |
          {{use '$parse-error'}}
          if self.context_stack.len() < 3 || !self.context_stack[2].is_html_element(tag!(Body)) || self.context().has_template_element() {
              {{use '$ignore-token'}}
          } else {
              self.frameset_ok = false;
              self.set_attributes_to_body_element(tag);
              Control::Continue
          }
      - match: <frameset>
        run: |
          {{use '$parse-error'}}
          if self.context_stack.len() < 3 || !self.context_stack[2].is_html_element(tag!(Body)) {
              {{use '$ignore-token'}}
          } else if !self.frameset_ok {
              {{use '$ignore-token'}}
          } else {
              while !self.context().is_html_element(tag!(Html)) {
                  self.remove_element();
              }
              self.push_html_frameset_element(tag);
              self.switch_to(mode!(InFrameset));
              Control::Continue
          }
      - match: eof
        run: |
          if !self.template_mode_stack.is_empty() {
              {{use '@in-template'}}
          } else {
              // TODO: If there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
              // TODO: Stop parsing.
              Control::Done
          }
      - match: </body>
        run: |
          if !self.context().has_body_element_in_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              // TODO: if there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
              self.switch_to(mode!(AfterBody));
              Control::Continue
          }
      - match: </html>
        run: |
          if !self.context().has_body_element_in_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              // TODO: if there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
              self.switch_to(mode!(AfterBody));
              Control::Reprocess
          }
      - match: >-
          <address> <article> <aside> <blockquote> <center> <details> <dialog>
          <dir> <div> <dl> <fieldset> <figcaption> <figure> <footer> <header>
          <hgroup> <main> <menu> <nav> <ol> <p> <search> <section> <summary> <ul>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <h1> <h2> <h3> <h4> <h5> <h6>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          if self.context().is_html_heading_element() {
              {{use '$parse-error'}}
              self.pop_element();
          }
          self.push_html_heading_element(tag);
          Control::Continue
      - match: <pre> <listing>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_{{tag_name}}_element(tag);
          self.ignore_lf = true;
          self.frameset_ok = false;
          Control::Continue
      - match: <form>
        run: |
          if self.form_element.is_some() && !self.context().has_template_element() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              if self.context().has_p_element_in_button_scope() {
                  self.close_p_element();
              }
              self.push_html_form_element(tag);
              if !self.context().has_template_element() {
                  self.form_element = Some(self.context().open_element.node);
              }
              Control::Continue
          }
      - match: <li>
        run: |
          self.frameset_ok = false;
          let mut context_pos = self.context_stack.len() - 1;
          loop {
              let context = &self.context_stack[context_pos];
              if context.is_html_element(tag!(Li)) {
                  self.close_implied_tags_except_for(tag!(Li));
                  if self.context().is_html_element(tag!(Li)) {
                      {{use '$parse-error'}}
                  }
                  while !self.context().is_html_element(tag!(Li)) {
                      self.pop_element();
                  }
                  self.pop_element(); // pop an html li element
                  break;
              }
              let local_name = context.local_name();
              if local_name.is_special() {
                  match local_name {
                      tag!(Address, Div, P) => (),
                      _ => break,
                  }
              }
              context_pos -= 1;
          }
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_li_element(tag);
          Control::Continue
      - match: <dd> <dt>
        run: |
          self.frameset_ok = false;
          let mut context_pos = self.context_stack.len() - 1;
          loop {
              let context = &self.context_stack[context_pos];
              if context.is_html_element(tag!(Dd)) {
                  self.close_implied_tags_except_for(tag!(Dd));
                  if !self.context().is_html_element(tag!(Dd)) {
                      {{use '$parse-error'}}
                  }
                  while !self.context().is_html_element(tag!(Dd)) {
                      self.pop_element();
                  }
                  self.pop_element(); // pop an html dd element
                  break;
              }
              if context.is_html_element(tag!(Dt)) {
                  self.close_implied_tags_except_for(tag!(Dt));
                  if !self.context().is_html_element(tag!(Dt)) {
                      {{use '$parse-error'}}
                  }
                  while !self.context().is_html_element(tag!(Dt)) {
                      self.pop_element();
                  }
                  self.pop_element(); // pop an html dt element
                  break;
              }
              let local_name = context.local_name();
              if local_name.is_special() && context.is_html() && !tags![Address, Div, P].contains(&local_name) {
                  break;
              }
              context_pos -= 1;
          }
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <plaintext>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_plaintext_element(tag);
          Control::SwitchTo(InitialState::Plaintext, "plaintext")
      - match: <button>
        run: |
          if self.context().has_button_element_in_scope() {
              {{use '$parse-error'}}
              self.close_implied_tags();
              while !self.context().is_html_element(tag!(Button)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html button element
          }
          self.reconstruct_active_formatting_elements();
          self.push_html_button_element(tag);
          self.frameset_ok = false;
          Control::Continue
      - match: >-
          </address> </article> </aside> </blockquote> </button> </center>
          </details> </dialog> </dir> </div> </dl> </fieldset> </figcaption>
          </figure> </footer> </header> </hgroup> </listing> </main> </menu>
          </nav> </ol> </pre> </search> </section> </summary> </ul>
        run: |
          if !self.context().has_{{tag_name}}_element_in_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!({{TagName}})) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html {{tag_name}} element
              Control::Continue
          }
      - match: </form>
        run: |
          // The HTML5 specification is unclear.
          // So, we implement the same step as html5ever.
          if !self.context().has_template_element() {
              let node = self.form_element.take();
              match node {
                  Some(node) => {
                      match self.find_element_in_scope(node) {
                          Ok(pos) => {
                              self.close_implied_tags();
                              if self.context().open_element.node != node {
                                  {{use '$parse-error'}}
                              }
                              self.context_stack.remove(pos);
                              Control::Continue
                          }
                          _ => {
                              {{use '$parse-error'}}
                              {{use '$ignore-token'}}
                          }
                      }
                  }
                  _ => {
                      {{use '$parse-error'}}
                      {{use '$ignore-token'}}
                  }
              }
          } else if !self.context().has_form_element_in_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!(Form)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Form)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html form element
              Control::Continue
          }
      - match: </p>
        run: |
          if !self.context().has_p_element_in_button_scope() {
              {{use '$parse-error'}}
              self.push_html_p_element(&Tag::with_no_attrs("p"));
          }
          self.close_p_element();
          Control::Continue
      - match: </li>
        run: |
          if !self.context().has_li_element_in_list_item_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags_except_for(tag!(Li));
              if !self.context().is_html_element(tag!(Li)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Li)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html li element
          }
          Control::Continue
      - match: </dd> </dt>
        run: |
          if !self.context().has_{{tag_name}}_element_in_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags_except_for(tag!({{TagName}}));
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!({{TagName}})) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html {{tag_name}} element
          }
          Control::Continue
      - match: </h1> </h2> </h3> </h4> </h5> </h6>
        run: |
          if !self.context().has_heading_element_in_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_heading_element() {
                  self.pop_element();
              }
              self.pop_element(); // pop an html heading element
          }
          Control::Continue
      - match: </sarcasm>
        run: |
          // TODO: Take a deep breath.
          {{use 'any-other-end-tag'}}
      - match: <a>
        run: |
          if let Some(i) = self.active_formatting_element_list.find_last_element(tag!(A)) {
              {{use '$parse-error'}}
              let node = self.active_formatting_element_list.get_element(i);
              self.perform_adoption_agency_algorithm(tag);
              if let Some(i) = self.active_formatting_element_list.find_element(node) {
                  self.active_formatting_element_list.0.remove(i);
                  self.context_stack.retain(|context| context.open_element.node != node);
              }
          }
          self.reconstruct_active_formatting_elements();
          self.push_html_a_element(tag);
          self.push_element_to_active_formatting_contexts(tag);
          Control::Continue
      - match: >-
          <b> <big> <code> <em> <font> <i> <s> <small> <strike> <strong> <tt>
          <u>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          self.push_element_to_active_formatting_contexts(tag);
          Control::Continue
      - match: <nobr>
        run: |
          self.reconstruct_active_formatting_elements();
          if self.context().has_nobr_element_in_scope() {
              {{use '$parse-error'}}
              self.perform_adoption_agency_algorithm(tag);
              self.reconstruct_active_formatting_elements();
          }
          self.push_html_nobr_element(tag);
          self.push_element_to_active_formatting_contexts(tag);
          Control::Continue
      - match: >-
          </a> </b> </big> </code> </em> </font> </i> </nobr> </s> </small>
          </strike> </strong> </tt> </u>
        run: |
          self.perform_adoption_agency_algorithm(tag);
          Control::Continue
      - match: <applet> <marquee> <object>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          self.push_marker_to_active_formatting_contexts();
          self.frameset_ok = false;
          Control::Continue
      - match: </applet> </marquee> </object>
        run: |
          if !self.context().has_{{tag_name}}_element_in_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!({{TagName}})) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html {{tag_name}} element
              self.pop_active_formatting_elements_up_to_marker();
          }
          Control::Continue
      - match: <table>
        run: |
          if self.quirks_mode != QuirksMode::Quirks && self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_table_element(tag);
          self.frameset_ok = false;
          self.switch_to(mode!(InTable));
          Control::Continue
      - match: </br>
        run: |
          {{use '$parse-error'}}
          let tag = &Tag::with_no_attrs("br"); // Drop the attributes
          {{use 'start-br'}}
      - match: <area> <br> <embed> <img> <keygen> <wbr>
        id: start-br
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          self.pop_element();
          if tag.self_closing {
              {{use '$acknowledge-self-closing' }}
          }
          self.frameset_ok = false;
          Control::Continue
      - match: <input>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_input_element(tag);
          self.pop_element();
          if Self::is_visible_input(tag) {
              self.frameset_ok = false;
          }
          Control::Continue
      - match: <param> <source> <track>
        run: |
          self.push_html_{{tag_name}}_element(tag);
          self.pop_element();
          if tag.self_closing {
              {{use '$acknowledge-self-closing' }}
          }
          Control::Continue
      - match: <hr>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_hr_element(tag);
          self.pop_element();
          if tag.self_closing {
              {{use '$acknowledge-self-closing' }}
          }
          self.frameset_ok = false;
          Control::Continue
      - match: <image>
        run: |
          {{use '$parse-error'}}
          self.handle_start_tag(tag.rename("img"))
      - match: <textarea>
        run: |
          self.push_html_textarea_element(tag);
          self.ignore_lf = true;
          self.frameset_ok = false;
          self.save_and_switch_to(mode!(Text));
          Control::SwitchTo(InitialState::Rcdata, "textarea")
      - match: <xmp>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.reconstruct_active_formatting_elements();
          self.frameset_ok = false;
          {{use '$generic-raw-text-element-parsing-algorithm'}}
      - match: <iframe>
        run: |
          self.frameset_ok = false;
          {{use '$generic-raw-text-element-parsing-algorithm'}}
      - match: <noembed>
        run: |
          {{use '$generic-raw-text-element-parsing-algorithm'}}
      # The corresponding rule in the HTML5 specification is expressed with a
      # guard condition.  But we moves it into the `run` expression in order
      # to simplify the format of this YAML file.
      - match: <noscript>
        run: |
          if self.scripting {
              {{use '$generic-raw-text-element-parsing-algorithm'}}
          } else {
              {{use 'any-other-start-tag'}}
          }
      - match: <select>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_select_element(tag);
          self.frameset_ok = false;
          self.switch_to(match self.mode {
              mode!(InTable, InCaption, InTableBody, InRow, InCell) => mode!(InSelectInTable),
              _ => mode!(InSelect),
          });
          Control::Continue
      - match: <optgroup> <option>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
          }
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <rb> <rtc>
        run: |
          if self.context().has_ruby_element_in_scope() {
              self.close_implied_tags();
          }
          if !self.context().is_html_element(tag!(Ruby)) {
              {{use '$parse-error'}}
          }
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <rp> <rt>
        run: |
          if self.context().has_ruby_element_in_scope() {
              self.close_implied_tags_except_for(tag!(Rtc));
          }
          if !self.context().is_one_of_html_elements(&tags![Ruby, Rtc]) {
              {{use '$parse-error'}}
          }
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <math>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_mathml_element(tag, tag!(Math));
          if tag.self_closing {
              self.pop_element();
              {{use '$acknowledge-self-closing' }}
          }
          Control::Continue
      - match: <svg>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_svg_element(tag, tag!(Svg));
          if tag.self_closing {
              self.pop_element();
              {{use '$acknowledge-self-closing' }}
          }
          Control::Continue
      - match: >-
          <caption> <col> <colgroup> <frame> <head> <tbody> <td> <tfoot> <th>
          <thead> <tr>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <_>
        id: any-other-start-tag
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: </_>
        id: any-other-end-tag
        run: |
          let mut context_pos = self.context_stack.len() - 1;
          loop {
              let context = &self.context_stack[context_pos];
              let element = context.open_element.node;
              if context.is_html() && context.open_element.has_same_name(tag.name) {
                  self.close_implied_tags_except_for(tag!({{TagName}})); // TODO
                  if element != self.context().open_element.node {
                      {{use '$parse-error'}}
                  }
                  while self.context_stack.len() > context_pos {
                      self.pop_element();
                  }
                  break;
              } else if context.open_element.local_name.is_special() {
                  {{use '$parse-error'}}
                  // Ignore the token.
                  break;
              }
              context_pos -= 1;
          }
          Control::Continue

  - name: text
    ref: parsing-main-incdata
    rules:
      - match: nul whitespace text
        run: |
          self.append_text(text.data);
          Control::Continue
      - match: eof
        run: |
          {{use '$parse-error'}}
          if self.context().is_html_element(tag!(Script)) {
              // TODO: set its already started to true.
          }
          self.pop_element();
          self.switch_to_original_mode();
          Control::Reprocess
      - match: </script>
        run: |
          // TODO: If the active speculative HTML parser is null and the JavaScript execution context stack is empty, then perform a microtask checkpoint.
          self.pop_element();
          self.switch_to_original_mode();
          Control::ExecuteScript
      - match: </_>
        run: |
          self.pop_element();
          self.switch_to_original_mode();
          Control::Continue

  - name: in-table
    ref: parsing-main-intable
    rules:
      - match: nul whitespace text
        run: |
          if self.context().is_one_of_html_elements(&tags![Table, Tbody, Template, Tfoot, Thead, Tr]) {
              self.append_text_if_exists();
              self.pending_table_text.clear();
              self.pending_table_text_contains_non_whitespace = false;
              self.save_and_switch_to(mode!(InTableText));
              Control::Reprocess
          } else {
              {{use 'anything-else'}}
          }
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <caption>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_caption_element(tag);
          self.push_marker_to_active_formatting_contexts();
          self.switch_to(mode!(InCaption));
          Control::Continue
      - match: <colgroup>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_colgroup_element(tag);
          self.switch_to(mode!(InColumnGroup));
          Control::Continue
      - match: <col>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_colgroup_element(&Tag::with_no_attrs("colgroup"));
          self.switch_to(mode!(InColumnGroup));
          Control::Reprocess
      - match: <tbody> <tfoot> <thead>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_{{tag_name}}_element(tag);
          self.switch_to(mode!(InTableBody));
          Control::Continue
      - match: <td> <th> <tr>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_tbody_element(&Tag::with_no_attrs("tbody"));
          self.switch_to(mode!(InTableBody));
          Control::Reprocess
      - match: <table>
        run: |
          {{use '$parse-error'}}
          if !self.context().has_table_element_in_table_scope() {
              {{use '$ignore-token'}}
          } else {
              while !self.context().is_html_element(tag!(Table)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html table element
              self.reset_insertion_mode_appropriately();
              Control::Reprocess
          }
      - match: </table>
        run: |
          if !self.context().has_table_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              while !self.context().is_html_element(tag!(Table)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html table element
              self.reset_insertion_mode_appropriately();
              Control::Continue
          }
      - match: >-
          </body> </caption> </col> </colgroup> </html> </tbody> </td> </tfoot>
          </th> </thead> </tr>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <style> <script> <template> </template>
        run: |
          {{use '@in-head'}}
      - match: <input>
        run: |
          if Self::is_visible_input(tag) {
              {{use 'anything-else'}}
          } else {
              {{use '$parse-error'}}
              self.push_html_input_element(tag);
              self.pop_element();
              if tag.self_closing {
                  {{use '$acknowledge-self-closing' }}
              }
              Control::Continue
          }
      - match: <form>
        run: |
          {{use '$parse-error'}}
          if self.context().has_template_element() || self.form_element.is_some() {
              {{use '$ignore-token'}}
          } else {
              self.push_html_form_element(tag);
              self.form_element = Some(self.context().open_element.node);
              self.pop_element();
              Control::Continue
          }
      - match: eof
        run: |
          {{use '@in-body'}}
      - match: any
        id: anything-else
        run: |
          {{use '$parse-error'}}
          self.enable_foster_parenting();
          let ctrl = {
              {{use '@in-body'}}
          };
          self.disable_foster_parenting();
          ctrl

  - name: in-table-text
    ref: parsing-main-intabletext
    rules:
      - match: nul
        run: |
          {{use '$ignore-token'}}
      - match: whitespace
        run: |
          self.pending_table_text.push_str(text.data);
          Control::Continue
      - match: text
        run: |
          self.pending_table_text.push_str(text.data);
          self.pending_table_text_contains_non_whitespace = true;
          Control::Continue
      - match: any
        run: |
          if self.pending_table_text_contains_non_whitespace {
              {{use '$parse-error'}}
              self.enable_foster_parenting();
              self.reconstruct_active_formatting_elements();
              let node = self.inner.create_text(self.pending_table_text.as_str());
              self.insert_node(node);
              self.pending_table_text.clear();
              self.pending_table_text_contains_non_whitespace = false;
              self.disable_foster_parenting();
          } else {
              let node = self.inner.create_text(self.pending_table_text.as_str());
              self.insert_node(node);
              self.pending_table_text.clear();
              self.pending_table_text_contains_non_whitespace = false;
          }
          self.switch_to_original_mode();
          Control::Reprocess

  - name: in-caption
    ref: parsing-main-incaption
    rules:
      - match: </caption>
        run: |
          if !self.context().has_caption_element_in_table_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!(Caption)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Caption)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html caption element
              self.active_formatting_element_list.clear_up_to_last_marker();
              self.switch_to(mode!(InTable));
          }
          Control::Continue
      - match: >-
          <caption> <col> <colgroup> <tbody> <td> <tfoot> <th> <thead> <tr>
          </table>
        run: |
          if !self.context().has_caption_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!(Caption)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Caption)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html caption element
              self.active_formatting_element_list.clear_up_to_last_marker();
              self.switch_to(mode!(InTable));
              Control::Reprocess
          }
      - match: >-
          </body> </col> </colgroup> </html> </tbody> </td> </tfoot> </th>
          </thead> </tr>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        run: |
          {{use '@in-body'}}

  - name: in-column-group
    ref: parsing-main-incolgroup
    rules:
      - match: whitespace
        run: |
          self.append_text(text.data);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <col>
        run: |
          self.push_html_col_element(tag);
          self.pop_element();
          if tag.self_closing {
              {{use '$acknowledge-self-closing' }}
          }
          Control::Continue
      - match: </colgroup>
        run: |
          if !self.context().is_html_element(tag!(Colgroup)) {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.pop_element();
              self.switch_to(mode!(InTable));
              Control::Continue
          }
      - match: </col>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <template> </template>
        run: |
          {{use '@in-head'}}
      - match: eof
        run: |
          {{use '@in-body'}}
      - match: any
        run: |
          if !self.context().is_html_element(tag!(Colgroup)) {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.pop_element();
              self.switch_to(mode!(InTable));
              Control::Reprocess
          }

  - name: in-table-body
    ref: parsing-main-intbody
    rules:
      - match: <tr>
        run: |
          self.clear_stack_back_to_table_body_context();
          self.push_html_tr_element(tag);
          self.switch_to(mode!(InRow));
          Control::Continue
      - match: <th> <td>
        run: |
          {{use '$parse-error'}}
          self.clear_stack_back_to_table_body_context();
          self.push_html_tr_element(&Tag::with_no_attrs("tr"));
          self.switch_to(mode!(InRow));
          Control::Reprocess
      - match: </tbody> </tfoot> </thead>
        run: |
          if !self.context().has_{{tag_name}}_element_in_table_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.clear_stack_back_to_table_body_context();
              self.pop_element();
              self.switch_to(mode!(InTable));
          }
          Control::Continue
      - match: <caption> <col> <colgroup> <tbody> <tfoot> <thead> </table>
        run: |
          if !self.context().has_rowgroup_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.clear_stack_back_to_table_body_context();
              self.pop_element();
              self.switch_to(mode!(InTable));
              Control::Reprocess
          }
      - match: </body> </caption> </col> </colgroup> </html> </td> </th> </tr>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        run: |
          {{use '@in-table'}}

  - name: in-row
    ref: parsing-main-intr
    rules:
      - match: <th> <td>
        run: |
          self.clear_stack_back_to_table_row_context();
          self.push_html_{{tag_name}}_element(tag);
          self.push_marker_to_active_formatting_contexts();
          self.switch_to(mode!(InCell));
          Control::Continue
      - match: </tr>
        run: |
          if !self.context().has_tr_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.clear_stack_back_to_table_row_context();
              debug_assert!(self.context().is_html_element(tag!(Tr)));
              self.pop_element();
              self.switch_to(mode!(InTableBody));
              Control::Continue
          }
      - match: <caption> <col> <colgroup> <tbody> <tfoot> <thead> <tr> </table>
        run: |
          if !self.context().has_tr_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.clear_stack_back_to_table_row_context();
              debug_assert!(self.context().is_html_element(tag!(Tr)));
              self.pop_element();
              self.switch_to(mode!(InTableBody));
              Control::Reprocess
          }
      - match: </tbody> </tfoot> </thead>
        run: |
          if !self.context().has_{{tag_name}}_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else if !self.context().has_tr_element_in_table_scope() {
              {{use '$ignore-token'}}
          } else {
              self.clear_stack_back_to_table_row_context();
              debug_assert!(self.context().is_html_element(tag!(Tr)));
              self.pop_element();
              self.switch_to(mode!(InTableBody));
              Control::Reprocess
          }
      - match: </body> </caption> </col> </colgroup> </html> </td> </th>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        run: |
          {{use '@in-table'}}

  - name: in-cell
    ref: parsing-main-intd
    rules:
      - match: </td> </th>
        run: |
          if !self.context().has_{{tag_name}}_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!({{TagName}})) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html {{tag_name}} element
              self.active_formatting_element_list.clear_up_to_last_marker();
              self.switch_to(mode!(InRow));
              Control::Continue
          }
      - match: <caption> <col> <colgroup> <tbody> <td> <tfoot> <th> <thead> <tr>
        run: |
          // We keep the following check for safety even though it's changed to an assertion
          // in the specification.  See whatwg/html@ab63afcb792f2558d0e4fd176999d5c520b49825.
          if !self.context().has_cell_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_cell();
              Control::Reprocess
          }
      - match: </body> </caption> </col> </colgroup> </html>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: </table> </tbody> </tfoot> </thead> </tr>
        run: |
          if !self.context().has_{{tag_name}}_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_cell();
              Control::Reprocess
          }
      - match: any
        run: |
          {{use '@in-body'}}

  - name: in-select
    ref: parsing-main-inselect
    rules:
      - match: nul
        run: |
          {{use '$ignore-token'}}
      - match: whitespace text
        run: |
          self.append_text(text.data);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <option>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
          }
          self.push_html_option_element(tag);
          Control::Continue
      - match: <optgroup>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
          }
          if self.context().is_html_element(tag!(Optgroup)) {
              self.pop_element();
          }
          self.push_html_optgroup_element(tag);
          Control::Continue
      - match: <hr>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
          }
          if self.context().is_html_element(tag!(Optgroup)) {
              self.pop_element();
          }
          self.push_html_hr_element(tag);
          self.pop_element();
          if tag.self_closing {
              {{use '$acknowledge-self-closing' }}
          }
          Control::Continue
      - match: </optgroup>
        run: |
          if self.context().is_html_element(tag!(Option)) && self.context_stack.len() > 1 {
              let prev_context_pos = self.context_stack.len() - 2;
              if self.context_stack[prev_context_pos].is_html_element(tag!(Optgroup)) {
                  self.pop_element();
              }
          }
          if self.context().is_html_element(tag!(Optgroup)) {
              self.pop_element();
              Control::Continue
          } else {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          }
      - match: </option>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
              Control::Continue
          } else {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          }
      - match: </select>
        run: |
          if !self.context().has_select_element_in_select_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              while !self.context().is_html_element(tag!(Select)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html select element
              self.reset_insertion_mode_appropriately();
              Control::Continue
          }
      - match: <select>
        run: |
          {{use '$parse-error'}}
          if !self.context().has_select_element_in_select_scope() {
              {{use '$ignore-token'}}
          } else {
              while !self.context().is_html_element(tag!(Select)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html select element
              self.reset_insertion_mode_appropriately();
              Control::Continue
          }
      - match: <input> <keygen> <textarea>
        run: |
          {{use '$parse-error'}}
          if !self.context().has_select_element_in_select_scope() {
              {{use '$ignore-token'}}
          } else {
              while !self.context().is_html_element(tag!(Select)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html select element
              self.reset_insertion_mode_appropriately();
              Control::Reprocess
          }
      - match: <script> <template> </template>
        run: |
          {{use '@in-head'}}
      - match: eof
        run: |
          {{use '@in-body'}}
      - match: any
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}

  - name: in-select-in-table
    ref: parsing-main-inselectintable
    rules:
      - match: <caption> <table> <tbody> <tfoot> <thead> <tr> <td> <th>
        run: |
          {{use '$parse-error'}}
          while !self.context().is_html_element(tag!(Select)) {
              self.pop_element();
          }
          self.pop_element(); // pop an html select element
          self.reset_insertion_mode_appropriately();
          Control::Reprocess
      - match: </caption> </table> </tbody> </tfoot> </thead> </tr> </td> </th>
        run: |
          {{use '$parse-error'}}
          if !self.context().has_table_element_in_table_scope() {
              {{use '$ignore-token'}}
          } else {
              while !self.context().is_html_element(tag!(Select)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html select element
              self.reset_insertion_mode_appropriately();
              Control::Reprocess
          }
      - match: any
        run: |
          {{use '@in-select'}}

  - name: in-template
    ref: parsing-main-intemplate
    rules:
      - match: nul whitespace text comment doctype
        run: |
          {{use '@in-body'}}
      - match: >-
          <base> <basefont> <bgsound> <link> <meta> <noframes> <script> <style>
          <template> <title> </template>
        run: |
          {{use '@in-head'}}
      - match: <caption> <colgroup> <tbody> <tfoot> <thead>
        run: |
          self.pop_template_mode();
          self.push_template_mode(mode!(InTable));
          self.switch_to(mode!(InTable));
          Control::Reprocess
      - match: <col>
        run: |
          self.pop_template_mode();
          self.push_template_mode(mode!(InColumnGroup));
          self.switch_to(mode!(InColumnGroup));
          Control::Reprocess
      - match: <tr>
        run: |
          self.pop_template_mode();
          self.push_template_mode(mode!(InTableBody));
          self.switch_to(mode!(InTableBody));
          Control::Reprocess
      - match: <td> <th>
        run: |
          self.pop_template_mode();
          self.push_template_mode(mode!(InRow));
          self.switch_to(mode!(InRow));
          Control::Reprocess
      - match: <_>
        run: |
          self.pop_template_mode();
          self.push_template_mode(mode!(InBody));
          self.switch_to(mode!(InBody));
          Control::Reprocess
      - match: </_>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: eof
        run: |
          if !self.context().has_template_element() {
              // TODO: Stop parsing.
              Control::Done
          } else {
              {{use '$parse-error'}}
              while !self.context().is_html_element(tag!(Template)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html template element
              self.active_formatting_element_list.clear_up_to_last_marker();
              self.pop_template_mode();
              self.reset_insertion_mode_appropriately();
              Control::Reprocess
          }

  - name: after-body
    ref: parsing-main-afterbody
    rules:
      - match: whitespace
        run: |
          {{use '@in-body'}}
      - match: comment
        run: |
          self.append_comment_to_document_element(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: </html>
        run: |
          if self.fragment_parsing_context.is_some() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.switch_to(mode!(AfterAfterBody));
              Control::Continue
          }
      - match: eof
        run: |
          Control::Done
      - match: any
        run: |
          {{use '$parse-error'}}
          self.switch_to(mode!(InBody));
          Control::Reprocess

  - name: in-frameset
    ref: parsing-main-inframeset
    rules:
      - match: whitespace
        run: |
          self.append_text(text.data);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <frameset>
        run: |
          self.push_html_frameset_element(tag);
          Control::Continue
      - match: </frameset>
        run: |
          if self.context().is_html_element(tag!(Html)) {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.pop_element();
              if self.fragment_parsing_context.is_none() && !self.context().is_html_element(tag!(Frameset)) {
                  self.switch_to(mode!(AfterFrameset));
              }
              Control::Continue
          }
      - match: <frame>
        run: |
          self.push_html_frame_element(tag);
          self.pop_element();
          if tag.self_closing {
              {{use '$acknowledge-self-closing' }}
          }
          Control::Continue
      - match: <noframes>
        run: |
          {{use '@in-head'}}
      - match: eof
        run: |
          if !self.context().is_html_element(tag!(Html)) {
              {{use '$parse-error'}}
          }
          Control::Done
      - match: any
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}

  - name: after-frameset
    ref: parsing-main-afterframeset
    rules:
      - match: whitespace
        run: |
          self.append_text(text.data);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: </html>
        run: |
          self.switch_to(mode!(AfterAfterFrameset));
          Control::Continue
      - match: <noframes>
        run: |
          {{use '@in-head'}}
      - match: eof
        run: |
          Control::Done
      - match: any
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}

  - name: after-after-body
    ref: the-after-after-body-insertion-mode
    rules:
      - match: comment
        run: |
          self.append_comment_to_document(&comment);
          Control::Continue
      - match: doctype whitespace <html>
        run: |
          {{use '@in-body'}}
      - match: eof
        run: |
          Control::Done
      - match: any
        run: |
          {{use '$parse-error'}}
          self.switch_to(mode!(InBody));
          Control::Reprocess

  - name: after-after-frameset
    ref: the-after-after-frameset-insertion-mode
    rules:
      - match: comment
        run: |
          self.append_comment_to_document(&comment);
          Control::Continue
      - match: doctype whitespace <html>
        run: |
          {{use '@in-body'}}
      - match: eof
        run: |
          Control::Done
      - match: <noframes>
        run: |
          {{use '@in-head'}}
      - match: any
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}

# Code snippets that can be referred by `$<snipetts.name>` from `run`.
snippets:
  ignore-token:
    code: |
      // Ignore the token.
      logger::debug!("Ignore the token");
      Control::Continue
  parse-error:
    if: enable-parse-error
    code: |
      // TODO: Parse error.
      logger::debug!("Parse error");
  acknowledge-self-closing:
    if: enable-parse-error
    code: |
      // TODO: non-void-html-element-start-tag-with-trailing-solidus parse error.
  generic-rcdata-element-parsing-algorithm:
    code: |
      self.push_html_{{tag_name}}_element(tag);
      self.save_and_switch_to(mode!(Text));
      Control::SwitchTo(InitialState::Rcdata, "{{tag_name}}")
  generic-raw-text-element-parsing-algorithm:
    code: |
      self.push_html_{{tag_name}}_element(tag);
      self.save_and_switch_to(mode!(Text));
      Control::SwitchTo(InitialState::Rawtext, "{{tag_name}}")
