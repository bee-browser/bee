// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{ template }}

#include "type_holder.hh"

#include <climits>

#define REG_NAME(expr) (enable_labels_ ? expr : "")

namespace {
constexpr unsigned kWorkBits = sizeof(size_t) * CHAR_BIT;
}

llvm::Type* TypeHolder::GetWordType() {
  return builder_.getIntNTy(kWorkBits);
}

llvm::Value* TypeHolder::GetWord(size_t value) {
  return builder_.getIntN(kWorkBits, value);
}

llvm::StructType* TypeHolder::CreateValueType() {
  if (value_type_ == nullptr) {
    value_type_ = llvm::StructType::create(context_, "Value");
    value_type_->setBody({
        // kind
        builder_.getInt8Ty(),
        // holder
        builder_.getInt64Ty(),
    });
  }
  return value_type_;
}

llvm::StructType* TypeHolder::CreatePropertyKeyType() {
  if (property_key_type_ == nullptr) {
    property_key_type_ = llvm::StructType::create(context_, "PropertyKey");
    property_key_type_->setBody({
      // kind
      builder_.getInt8Ty(),
      // holder
      builder_.getInt64Ty(),
    });
  }
  return property_key_type_;
}

llvm::StructType* TypeHolder::CreateChar16SeqType() {
  if (char16_seq_type_ == nullptr) {
    char16_seq_type_ = llvm::StructType::create(context_, "Char16Seq");
    char16_seq_type_->setBody({
        // next
        builder_.getPtrTy(),
        // ptr
        builder_.getPtrTy(),
        // len
        builder_.getInt32Ty(),
        // kind
        builder_.getInt8Ty(),
    });
  }
  return char16_seq_type_;
}

llvm::StructType* TypeHolder::CreateCaptureType() {
  if (capture_type_ == nullptr) {
    capture_type_ = llvm::StructType::create(context_, "Capture");
    capture_type_->setBody({
        // target
        builder_.getPtrTy(),
        // escaped
        CreateValueType(),
    });
  }
  return capture_type_;
}

llvm::StructType* TypeHolder::CreateClosureType() {
  if (closure_type_ == nullptr) {
    closure_type_ = llvm::StructType::create(context_, "Closure");
    closure_type_->setBody({
        // lambda
        builder_.getPtrTy(),
        // num_captures
        builder_.getInt16Ty(),
        // captures[]
        builder_.getPtrTy(),
    });
  }
  return closure_type_;
}

llvm::StructType* TypeHolder::CreateCoroutineType() {
  if (coroutine_type_ == nullptr) {
    coroutine_type_ = llvm::StructType::create(context_, "Coroutine");
    coroutine_type_->setBody({
        // closure
        builder_.getPtrTy(),
        // state
        builder_.getInt32Ty(),
        // num_locals
        builder_.getInt16Ty(),
        // scope_id
        builder_.getInt16Ty(),
        // scrach_buffer_len,
        builder_.getInt16Ty(),
        // locals[]
        CreateValueType(),
    });
  }
  return coroutine_type_;
}

llvm::FunctionType* TypeHolder::CreateLambdaType() {
  if (lambda_type_ == nullptr) {
    lambda_type_ = llvm::FunctionType::get(
        // status code
        builder_.getInt32Ty(),
        {
            // runtime (pointer to the runtime)
            builder_.getPtrTy(),
            // context (pointer to a contextual data)
            builder_.getPtrTy(),
            // argc
            GetWordType(),
            // argv (pointer to a list of values)
            builder_.getPtrTy(),
            // retv (pointer to a return value)
            builder_.getPtrTy(),
        },
        false);
  }
  return lambda_type_;
}
{%- for function in data.functions %}

llvm::Function* TypeHolder::CreateRuntime{{ function.name | pascalCase }}() {
  if (runtime_{{ function.name }}_ == nullptr) {
    auto* prototype = llvm::FunctionType::get(
        // {{ function.c_ret }}
        {{ function.llvmir_ret }},
        {
            {%- for arg in function.args %}
            // {{arg.ctype}} {{ arg.name }}
            {{ arg.llvmir_type }},
            {%- endfor %}
        },
        false);
    runtime_{{ function.name }}_ = llvm::Function::Create(prototype, llvm::Function::ExternalLinkage, "runtime_{{ function.name }}", module_);
    {%- for arg in function.args %}
    runtime_{{ function.name }}_->getArg({{ loop.index0 }})->setName(REG_NAME("{{ arg.name }}"));
    {%- endfor %}
  }
  return runtime_{{ function.name }}_;
}
{%- endfor %}
