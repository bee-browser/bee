// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{ template }}

use std::cell::OnceCell;

use cranelift::codegen::ir;
use cranelift_jit::JITBuilder;
use cranelift_module::FuncId;
use cranelift_module::Linkage;
use cranelift_module::Module;

use crate::backend::RuntimeFunctions;

pub fn register_symbols(builder: &mut JITBuilder, funcs: &RuntimeFunctions) {
    {%- for func in data.functions %}
    builder.symbol("runtime_{{ func.name }}", funcs.{{ func.name }} as *const u8);
    {%- endfor %}
}

pub struct RuntimeFunctionIds {
    // TODO(feat): if cfg!(feature = "libm")
    fmod: FuncId,
    // TODO(feat): if cfg!(feature = "libm")
    pow: FuncId,

    {%- for func in data.functions %}
    #[allow(unused)]
    {{ func.name }}: FuncId,
    {%- endfor %}
}

pub fn declare_functions<T: Module>(module: &mut T) -> RuntimeFunctionIds {
    let ptr_type = module.target_config().pointer_type();

    // TODO(feat): if cfg!(feature = "libm")
    let name = "fmod";
    let mut sig = module.make_signature();
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.returns.push(ir::AbiParam::new(ir::types::F64));
    let fmod = module.declare_function(name, Linkage::Import, &sig).unwrap();

    // TODO(feat): if cfg!(feature = "libm")
    let name = "pow";
    let mut sig = module.make_signature();
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.returns.push(ir::AbiParam::new(ir::types::F64));
    let pow = module.declare_function(name, Linkage::Import, &sig).unwrap();
    {%- for func in data.functions %}

    let name = "runtime_{{ func.name }}";
    let mut sig = module.make_signature();
    {%- for arg in func.args %}
    sig.params.push(ir::AbiParam::new({{ arg.clir_type }}));
    {%- endfor %}
    {%- if func.clir_ret %}
    sig.returns.push(ir::AbiParam::new({{ func.clir_ret }}));
    {%- endif %}
    let {{ func.name }} = module.declare_function(name, Linkage::Import, &sig).unwrap();
    {%- endfor %}

    RuntimeFunctionIds {
        fmod,
        pow,
        {%- for func in data.functions %}
        {{ func.name }},
        {%- endfor %}
    }
}

pub struct RuntimeFunctionCache<'c> {
    ids: &'c RuntimeFunctionIds,
    // TODO(feat): if cfg!(feature = "libm")
    #[allow(unused)]
    fmod: OnceCell<ir::FuncRef>,
    // TODO(feat): if cfg!(feature = "libm")
    #[allow(unused)]
    pow: OnceCell<ir::FuncRef>,

    {%- for func in data.functions %}
    #[allow(unused)]
    {{ func.name }}: OnceCell<ir::FuncRef>,
    {%- endfor %}
}

impl<'c> RuntimeFunctionCache<'c> {
    pub fn new(ids: &'c RuntimeFunctionIds) -> Self {
        Self {
            ids,
            // TODO(feat): if cfg!(feature = "libm")
            fmod: Default::default(),
            // TODO(feat): if cfg!(feature = "libm")
            pow: Default::default(),
            {%- for func in data.functions %}
            {{ func.name }}: Default::default(),
            {%- endfor %}
        }
    }

    // TODO(feat): if cfg!(feature = "libm")
    #[allow(unused)]
    pub fn get_fmod<T: Module>(&self, module: &mut T, func: &mut ir::Function) -> ir::FuncRef {
        *self.fmod.get_or_init(|| module.declare_func_in_func(self.ids.fmod, func))
    }

    // TODO(feat): if cfg!(feature = "libm")
    #[allow(unused)]
    pub fn get_pow<T: Module>(&self, module: &mut T, func: &mut ir::Function) -> ir::FuncRef {
        *self.pow.get_or_init(|| module.declare_func_in_func(self.ids.pow, func))
    }
    {%- for func in data.functions %}

    #[allow(unused)]
    pub fn get_{{ func.name }}<T: Module>(&self, module: &mut T, func: &mut ir::Function) -> ir::FuncRef {
        *self.{{ func.name }}.get_or_init(|| module.declare_func_in_func(self.ids.{{ func.name }}, func))
    }
    {%- endfor %}
}
