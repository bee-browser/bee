// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: ../builtin_mod.rs.mustache

mod imp;

use jsparser::Symbol;

use crate::Runtime;
use crate::logger;
use crate::objects::ObjectHandle;
use crate::objects::Property;
use crate::types::CallContext;
use crate::types::Status;
use crate::types::Value;

use super::BuiltinFunctionParams;

impl<X> Runtime<X> {
    /// Returns `true` if `object` is a {{metadata.class}} object.
    #[allow(unused)]
    pub(crate) fn is_{{metadata.id}}_object(&self, object: ObjectHandle) -> bool {
        object.is_instance_of(self.{{metadata.id}}_prototype)
    }

    /// Returns `true` if `value` holds a {{metadata.class}} object.
    #[allow(unused)]
    pub(crate) fn value_is_{{metadata.id}}_object(&self, value: &Value) -> bool {
        matches!(value, Value::Object(object) if self.is_{{metadata.id}}_object(*object))
    }
    {{#constructorProperties}}

    /// Creates the {{metadata.class}} constructor.
    pub(super) fn create_{{metadata.id}}_constructor(&mut self) -> ObjectHandle {
        logger::debug!(event = "create_{{metadata.id}}_constructor");
        debug_assert!(self.{{metadata.id}}_prototype.is_some());

        let {{#functions.length}}mut {{/functions.length}}constructor = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: constructor::<X>,
            name: const_string!("{{metadata.class}}"),
            length: 1,
            slots: &[],
            prototype: self.{{metadata.id}}_prototype,
        });

        {{#functions}}
        let func = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: {{{imp}}},
            name: const_string!("{{{name}}}"),
            length: {{{length}}},
            slots: &[],
            prototype: None,
        });
        let _ = constructor.define_own_property(Symbol::{{{symbol}}}.into(), Property::data_wxc(Value::Object(func)));

        {{/functions}}
        // TODO(refactor): bind outside this function
        if let Some(mut prototype) = self.{{metadata.id}}_prototype {
            let _ = prototype.define_own_property(Symbol::CONSTRUCTOR.into(), Property::data_wxc(Value::Object(constructor)));
        }

        constructor
    }
    {{/constructorProperties}}
    {{#prototypeProperties}}

    /// Creates the {{metadata.class}} prototype object.
    pub(super) fn create_{{metadata.id}}_prototype(&mut self) -> ObjectHandle {
        logger::debug!(event = "creater_{{metadata.id}}_prototype");
        debug_assert!(self.object_prototype.is_some());
        debug_assert!(self.function_prototype.is_some());

        {{#functions.length}}
        let mut prototype = self.create_object(self.object_prototype);

        {{#functions}}
        let func = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: {{{imp}}},
            name: const_string!("{{{name}}}"),
            length: {{{length}}},
            slots: &[],
            prototype: None,
        });
        let _ = prototype.define_own_property(Symbol::{{{symbol}}}.into(), Property::data_wxc(Value::Object(func)));

        {{/functions}}
        prototype
        {{/functions.length}}
        {{^functions.length}}
        self.create_object(self.object_prototype)
        {{/functions.length}}
    }
    {{/prototypeProperties}}
}

// lambda functions
// TODO: use proc-macro

extern "C" fn constructor<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::constructor(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{#constructorProperties.functions}}

extern "C" fn {{imp}}<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::{{imp}}(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{/constructorProperties.functions}}
{{#prototypeProperties.functions}}

extern "C" fn {{imp}}<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::{{imp}}(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{/prototypeProperties.functions}}
