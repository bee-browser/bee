// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{@template}}

use std::cell::OnceCell;

use cranelift::codegen::ir;
use cranelift_jit::JITBuilder;
use cranelift_module::FuncId;
use cranelift_module::Linkage;
use cranelift_module::Module;

{{#each functions}}
use crate::backend::bridge::runtime_{{name}};
{{/each}}

use super::compiler;

// TODO(perf): using libm causes the following error in the coverage test w/ llvm-cov:
// "can't resolve symbol fmod"
extern "C" fn fmod(a: f64, b: f64) -> f64 {
    a % b
}

// TODO(perf): using libm causes the following error in the coverage test w/ llvm-cov:
// "can't resolve symbol pow"
extern "C" fn pow(a: f64, b: f64) -> f64 {
    a.powf(b)
}

pub fn register_symbols<X>(builder: &mut JITBuilder) {
    builder.symbol("fmod", fmod as *const u8);
    builder.symbol("pow", pow as *const u8);
    {{#each functions}}
    builder.symbol("runtime_{{name}}", runtime_{{name}}::<X> as *const u8);
    {{/each}}
}

#[derive(Clone)]
pub struct RuntimeFunctionIds {
    // TODO(feat): if cfg!(feature = "libm")
    pub fmod: FuncId,
    // TODO(feat): if cfg!(feature = "libm")
    pub pow: FuncId,
    {{#each functions}}
    #[allow(unused)]
    pub {{name}}: FuncId,
    {{/each}}
}

pub fn make_lambda_signature(module: &mut impl Module) -> ir::Signature {
    let mut sig = module.make_signature();
    let addr_type = module.target_config().pointer_type();

    // runtime: &mut Runtime<X>
    sig.params.push(ir::AbiParam::new(addr_type));
    // context: &mut CallContext
    sig.params.push(ir::AbiParam::new(addr_type));
    // retv: &mut Value
    sig.params.push(ir::AbiParam::new(addr_type));

    // #[repr(u32)] Status
    sig.returns.push(ir::AbiParam::new(ir::types::I32));

    sig
}

pub fn declare_functions(module: &mut impl Module) -> RuntimeFunctionIds {
    let addr_type = module.target_config().pointer_type();

    // TODO(feat): if cfg!(feature = "libm")
    let name = "fmod";
    let mut sig = module.make_signature();
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.returns.push(ir::AbiParam::new(ir::types::F64));
    let fmod = module.declare_function(name, Linkage::Import, &sig).unwrap();

    // TODO(feat): if cfg!(feature = "libm")
    let name = "pow";
    let mut sig = module.make_signature();
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.returns.push(ir::AbiParam::new(ir::types::F64));
    let pow = module.declare_function(name, Linkage::Import, &sig).unwrap();
    {{#each functions}}

    let name = "runtime_{{name}}";
    let mut sig = module.make_signature();
    {{#each args}}
    sig.params.push(ir::AbiParam::new({{clir_type}}));
    {{/each}}
    {{#if clir_ret}}
    sig.returns.push(ir::AbiParam::new({{clir_ret}}));
    {{/if}}
    let {{name}} = module.declare_function(name, Linkage::Import, &sig).unwrap();
    {{/each}}

    RuntimeFunctionIds {
        fmod,
        pow,
        {{#each functions}}
        {{name}},
        {{/each}}
    }
}

pub trait EditorSupport {
    // TODO(feat): if cfg!(feature = "libm")
    fn import_fmod(&mut self, func: &mut ir::Function) -> ir::FuncRef;
    // TODO(feat): if cfg!(feature = "libm")
    fn import_pow(&mut self, func: &mut ir::Function) -> ir::FuncRef;
    {{#each functions}}
    fn import_runtime_{{name}}(&mut self, func: &mut ir::Function) -> ir::FuncRef;
    {{/each}}
}

impl<X> EditorSupport for compiler::Session<'_, X> {
    fn import_fmod(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.code_registry.import_fmod(func)
    }

    fn import_pow(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.code_registry.import_pow(func)
    }
    {{#each functions}}

    fn import_runtime_{{name}}(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.code_registry.import_runtime_{{name}}(func)
    }
    {{/each}}
}

impl<X> EditorSupport for crate::backend::clir::CodeRegistry<X> {
    fn import_fmod(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.module.as_mut().unwrap().declare_func_in_func(self.runtime_func_ids.fmod, func)
    }

    fn import_pow(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.module.as_mut().unwrap().declare_func_in_func(self.runtime_func_ids.pow, func)
    }
    {{#each functions}}

    fn import_runtime_{{name}}(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.module.as_mut().unwrap().declare_func_in_func(self.runtime_func_ids.{{name}}, func)
    }
    {{/each}}
}

#[derive(Default)]
pub struct RuntimeFunctionCache {
    // TODO(feat): if cfg!(feature = "libm")
    fmod: OnceCell<ir::FuncRef>,
    // TODO(feat): if cfg!(feature = "libm")
    pow: OnceCell<ir::FuncRef>,
    {{#each functions}}
    #[allow(unused)]
    {{name}}: OnceCell<ir::FuncRef>,
    {{/each}}
}

impl RuntimeFunctionCache {
    // TODO(feat): if cfg!(feature = "libm")
    pub fn import_fmod(&self, support: &mut impl EditorSupport, func: &mut ir::Function) -> ir::FuncRef {
        *self.fmod.get_or_init(|| support.import_fmod(func))
    }

    // TODO(feat): if cfg!(feature = "libm")
    pub fn import_pow(&self, support: &mut impl EditorSupport, func: &mut ir::Function) -> ir::FuncRef {
        *self.pow.get_or_init(|| support.import_pow(func))
    }
    {{#each functions}}

    #[allow(unused)]
    pub fn import_runtime_{{name}}(&self, support: &mut impl EditorSupport, func: &mut ir::Function) -> ir::FuncRef {
        *self.{{name}}.get_or_init(|| support.import_runtime_{{name}}(func))
    }
    {{/each}}
}
