// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{ template }}

#include "executor.hh"

#include <cmath>
#include <limits>

#include "runtime.hh"

static llvm::ExitOnError ExitOnErr;

extern "C" bool to_boolean(const Value* value) {
  switch (value->kind) {
    case ValueKind::Undefined:
      return false;
    case ValueKind::Boolean:
      return value->holder.boolean;
    case ValueKind::Number:
      if (value->holder.number == 0.0) {
        return false;
      }
      if (std::isnan(value->holder.number)) {
        return false;
      }
      return true;
    default:
      return false;
  }
}

extern "C" double to_numeric(const Value* value) {
  switch (value->kind) {
    case ValueKind::Undefined:
      return std::numeric_limits<double>::quiet_NaN();
    case ValueKind::Boolean:
      return value->holder.boolean ? 1.0 : 0.0;
    case ValueKind::Number:
      return value->holder.number;
    default:
      return std::numeric_limits<double>::quiet_NaN();
  }
}

void Executor::RegisterRuntime(const Runtime* runtime) {
  llvm::orc::SymbolMap symbols;
  symbols[exec_session().intern("to_boolean")] = {
    llvm::orc::ExecutorAddr::fromPtr(to_boolean),
    llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("to_numeric")] = {
    llvm::orc::ExecutorAddr::fromPtr(to_numeric),
    llvm::JITSymbolFlags::Exported,
  };
  {%- for function in data.functions %}
  symbols[exec_session().intern("runtime_{{ function.name }}")] = {
    llvm::orc::ExecutorAddr::fromPtr(runtime->{{ function.name }}),
    llvm::JITSymbolFlags::Exported,
  };
  {%- endfor %}
  ExitOnErr(main_jd().define(llvm::orc::absoluteSymbols(std::move(symbols))));
}
