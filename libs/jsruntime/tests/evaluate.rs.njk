// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{ template }}

// Tests contained in this file are not exhaustive.
// We'll use tc39/test262 eventually.

use assert_matches::assert_matches;
use base::macros::assert_eq;
use jsruntime::Runtime;
use jsruntime::Value;

logging::init!();

#[ctor::ctor]
fn init_jsruntime() {
    jsruntime::initialize();
}

struct Validator {
    expected_values: Vec<Value>,
    actual_values: Vec<Value>,
}

impl Drop for Validator {
    fn drop(&mut self) {
        assert_eq!(self.actual_values.len(), self.expected_values.len());
        for (actual, expected) in self.actual_values.iter().zip(self.expected_values.iter()) {
            // Some cases including `f64::NAN` fail in `assert_eq!()`.
            let actual = format!("{actual:?}");
            let expected = format!("{expected:?}");
            assert_eq!(actual, expected);
        }
    }
}

fn evaluate(src: &str, optimize: bool, enable_labels: bool, expected_values: Vec<Value>) -> Result<Value, Value> {
    let mut runtime = Runtime::with_extension(Validator {
        expected_values,
        actual_values: vec![],
    });
    runtime.enable_scope_cleanup_checker();
    if enable_labels {
        runtime.enable_llvmir_labels();
    }
    runtime.register_host_function("print", |runtime, args| {
        // FIXME(issue#260): bindgen derives `Copy` and `Clone` for all types by default and
        // provides `no_copy()`.  However, `no_copy()` stops deriving `Copy` and `Clone` for
        // specific types.  There are no function to stop deriving only `Copy` for specific
        // types...
        //
        // We plan to implement own code generator in the future.  For a meanwhile, we silence
        // `clippy`.
        #[allow(clippy::clone_on_copy)]
        runtime.extension_mut().actual_values.push(args[0].clone());
    });
    let program = runtime.parse_script(src).unwrap();
    let module = runtime.compile(&program, optimize).unwrap();
    runtime.evaluate(module)
}
{%- for test in data.tests %}

#[test]
fn {{ test.name }}_optimize() {
   {{ test.name }}(true, false);
}

#[test]
fn {{ test.name }}_no_optimize() {
   {{ test.name }}(false, false);
}

#[test]
fn {{ test.name }}_with_labels() {
   {{ test.name }}(false, true);
}

fn {{ test.name }}(optimize: bool, enable_labels: bool) {
    let src = include_str!("{{ test.name }}.js");
    let result = evaluate(src, optimize, enable_labels, vec![
        {%- for expected in test.expectedValues %}
        {%- if expected === "Value::UNDEFINED" %}
        {{ expected }},
        {%- elif expected === "Value::NULL" %}
        {{ expected }},
        {%- else %}
        Value::from({{ expected }}),
        {%- endif %}
        {%- endfor %}
    ]);
    {%- if test.throws %}
    assert_matches!(result, Err(actual) => {
        // Some cases including `f64::NAN` fail in `assert_eq!()`.
        let actual = format!("{actual:?}");
        {%- if test.throws === "Value::UNDEFINED" %}
        let expected = format!("{:?}", {{ test.throws }});
        {%- elif test.throws === "Value::NULL" %}
        let expected = format!("{:?}", {{ test.throws }});
        {%- else %}
        let expected = format!("{:?}", Value::from({{ test.throws }}));
        {%- endif %}
        assert_eq!(actual, expected);
    });
    {%- else %}
    assert_matches!(result, Ok(_));
    {%- endif %}
}
{%- endfor %}
