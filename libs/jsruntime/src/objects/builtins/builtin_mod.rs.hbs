// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{@template}}

mod imp;

use jsparser::Symbol;

use crate::Runtime;
use crate::logger;
use crate::objects::ObjectHandle;
use crate::objects::Property;
use crate::types::CallContext;
use crate::types::Status;
use crate::types::Value;

use super::BuiltinFunctionParams;

impl<X> Runtime<X> {
    /// Returns `true` if `object` is a {{metadata.class}} object.
    #[allow(unused)]
    pub(crate) fn is_{{metadata.id}}_object(&self, object: ObjectHandle) -> bool {
        object.is_instance_of(self.{{metadata.id}}_prototype)
    }

    /// Returns `true` if `value` holds a {{metadata.class}} object.
    #[allow(unused)]
    pub(crate) fn value_is_{{metadata.id}}_object(&self, value: &Value) -> bool {
        matches!(value, Value::Object(object) if self.is_{{metadata.id}}_object(*object))
    }

    /// Creates the {{metadata.class}} constructor.
    pub(super) fn create_{{metadata.id}}_constructor(&mut self) -> ObjectHandle {
        logger::debug!(event = "create_{{metadata.id}}_constructor");
        debug_assert!(self.{{metadata.id}}_prototype.is_some());

        #[allow(unused_mut)]
        let mut constructor = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: constructor::<X>,
            name: const_string!("{{metadata.class}}"),
            length: 1,
            slots: &[],
            prototype: self.{{metadata.id}}_prototype,
        });

        {{#each constructorProperties}}
        {{#if (eq kind "constructor.function")}}
        let func = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: {{imp}},
            name: const_string!("{{name}}"),
            length: {{this.length}},
            slots: &[],
            prototype: None,
        });
        let _ = constructor.define_own_property(Symbol::{{symbol}}.into(), Property::data_wxc(Value::Object(func)));

        {{/if}}
        {{/each}}
        // TODO(refactor): bind outside this function
        if let Some(mut prototype) = self.{{metadata.id}}_prototype {
            let _ = prototype.define_own_property(Symbol::CONSTRUCTOR.into(), Property::data_wxc(Value::Object(constructor)));
        }

        constructor
    }

    /// Creates the {{metadata.class}} prototype object.
    pub(super) fn create_{{metadata.id}}_prototype(&mut self) -> ObjectHandle {
        logger::debug!(event = "creater_{{metadata.id}}_prototype");
        debug_assert!(self.{{metadata.inherits}}_prototype.is_some());
        debug_assert!(self.function_prototype.is_some());

        #[allow(unused_mut)]
        let mut prototype = self.create_object(self.{{metadata.inherits}}_prototype);

        {{#each prototypeProperties}}
        {{#if (eq kind "prototype.property")}}
        imp::{{imp}}(self, prototype);

        {{else if (eq kind "prototype.function")}}
        let func = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: {{imp}},
            name: const_string!("{{name}}"),
            length: {{this.length}},
            slots: &[],
            prototype: None,
        });
        let _ = prototype.define_own_property(Symbol::{{symbol}}.into(), Property::data_wxc(Value::Object(func)));

        {{/if}}
        {{/each}}
        prototype
    }
}

// lambda functions
// TODO: use proc-macro

extern "C" fn constructor<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::constructor(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{#each constructorProperties}}
{{#if (eq kind "constructor.function")}}

extern "C" fn {{imp}}<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::{{imp}}(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{/if}}
{{/each}}
{{#each prototypeProperties}}
{{#if (eq kind "prototype.function")}}

extern "C" fn {{imp}}<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::{{imp}}(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{{/if}}
{{/each}}
