// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated by:
// bee-tools-codegen.js --input-stdin mod.rs.hbs

mod any_other;
mod b;
mod body;
mod colgroup;
mod frameset;
mod head;
mod html;
mod input;
mod math;
mod p;
mod plaintext;
mod pre;
mod script;
mod style;
mod svg;
mod table;
mod td;
mod textarea;
mod title;
mod tr;

use super::*;

impl<W> TreeBuilder<W>
where
    W: DocumentWriter,
{
    pub fn handle_start_tag(&mut self, tag: Tag<'_>) -> Control {
        self.ignore_lf = false;
        match LocalName::lookup(tag.name) {
            tag!(B) => self.handle_start_b(&tag),
            tag!(Body) => self.handle_start_body(&tag),
            tag!(Colgroup) => self.handle_start_colgroup(&tag),
            tag!(Frameset) => self.handle_start_frameset(&tag),
            tag!(Head) => self.handle_start_head(&tag),
            tag!(Html) => self.handle_start_html(&tag),
            tag!(Input) => self.handle_start_input(&tag),
            tag!(Math) => self.handle_start_math(&tag),
            tag!(P) => self.handle_start_p(&tag),
            tag!(Plaintext) => self.handle_start_plaintext(&tag),
            tag!(Pre) => self.handle_start_pre(&tag),
            tag!(Script) => self.handle_start_script(&tag),
            tag!(Style) => self.handle_start_style(&tag),
            tag!(Svg) => self.handle_start_svg(&tag),
            tag!(Table) => self.handle_start_table(&tag),
            tag!(Td) => self.handle_start_td(&tag),
            tag!(Textarea) => self.handle_start_textarea(&tag),
            tag!(Tr) => self.handle_start_tr(&tag),
            tag!(Title) => self.handle_start_title(&tag),
            _ => self.handle_start_any_other(&tag),
        }
    }

    pub fn handle_end_tag(&mut self, tag: Tag<'_>) -> Control {
        self.ignore_lf = false;
        match LocalName::lookup(tag.name) {
            tag!(B) => self.handle_end_b(&tag),
            tag!(Body) => self.handle_end_body(&tag),
            tag!(Colgroup) => self.handle_end_colgroup(&tag),
            tag!(Frameset) => self.handle_end_frameset(&tag),
            tag!(Head) => self.handle_end_head(&tag),
            tag!(Html) => self.handle_end_html(&tag),
            tag!(Input) => self.handle_end_input(&tag),
            tag!(Math) => self.handle_end_math(&tag),
            tag!(P) => self.handle_end_p(&tag),
            tag!(Plaintext) => self.handle_end_plaintext(&tag),
            tag!(Pre) => self.handle_end_pre(&tag),
            tag!(Script) => self.handle_end_script(&tag),
            tag!(Style) => self.handle_end_style(&tag),
            tag!(Svg) => self.handle_end_svg(&tag),
            tag!(Table) => self.handle_end_table(&tag),
            tag!(Td) => self.handle_end_td(&tag),
            tag!(Textarea) => self.handle_end_textarea(&tag),
            tag!(Tr) => self.handle_end_tr(&tag),
            tag!(Title) => self.handle_end_title(&tag),
            _ => self.handle_end_any_other(&tag),
        }
    }

    fn has_template_element(&mut self) -> bool {
        // TODO
        false
    }

    fn set_attributes_to_html_element(&mut self, tag: &Tag<'_>) {
        // TODO
    }

    fn set_attributes_to_body_element(&mut self, tag: &Tag<'_>) {
        // TODO
    }

    fn reset_insertion_mode_appropriately(&mut self) {
        self.switch_to(self.context.reset_mode);
    }

    fn clear_stack_back_to_table_context(&mut self) {
        loop {
            match self.context.local_name {
                tag!(Html, Table, Template) => break,
                _ => self.remove_element(),
            }
        }
    }

    fn clear_stack_back_to_table_body_context(&mut self) {
        loop {
            match self.context.local_name {
                tag!(Tbody, Tfoot, Thead) => break,
                _ => self.remove_element(),
            }
        }
    }

    fn clear_stack_back_to_table_row_context(&mut self) {
        loop {
            match self.context.local_name {
                tag!(Html, Template, Tr) => break,
                _ => self.remove_element(),
            }
        }
    }

    fn close_cell(&mut self) {
        // TODO: Generate implied end tags.
        loop {
            match self.context.local_name {
                tag!(Td, Th) => {
                    self.pop_element();
                    break;
                }
                _ => {
                    // TODO: Parse error.
                    self.pop_element();
                }
            }
        }
        // TODO: Clear the list of active formatting elements up to the last marker.
        self.switch_to(mode!(InRow));
    }

    fn close_p_element_in_button_scope(&mut self) {
        // TODO
    }

    fn is_visible_input(tag: &Tag<'_>) -> bool {
        debug_assert!(tag.name == "input");
        for (name, value) in tag.attrs() {
            if name == "type" {
                if value.eq_ignore_ascii_case("hidden") {
                    return false;
                }
                return true;
            }
        }
        true
    }
}
