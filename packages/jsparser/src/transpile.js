'use strict';

import {
  assert,
  assertEquals,
  assertExists,
  unreachable,
} from 'https://deno.land/std@0.193.0/testing/asserts.ts';
import * as log from 'https://deno.land/std@0.193.0/log/mod.ts';
import * as yaml from 'https://deno.land/std@0.193.0/yaml/mod.ts';
import { parseCommand, readAllText } from '../../../tools/lib/cli.js';
import { setup } from '../../../tools/lib/log.js';

const PROGNAME = 'transpile.js';

const DOC = `
Transpile an ECMA lexical grammer from the text format to the YAML format.

Usage:
  ${PROGNAME} [options]
  ${PROGNAME} -h | --help

Options:
  -d, --debug
    Enable debug logs.

  -g, --grammar-type=<grammar-type>
    The type of grammar to transpile.

  -t, --tokens=<tokens-json>
    Path to a tokens.json.
`.trim();

const HEADER = `
# DO NOT EDIT THIS FILE BY HAND.
#
# This file was automagically generated by ${PROGNAME}.
`.trim();

async function run(options) {
  if (options.debug) {
    setup(PROGNAME, 'DEBUG');
  } else {
    setup(PROGNAME, 'INFO');
  }
  const transpiler = new Transpiler(options);
  printYaml(await transpiler.transpile());
}

function transform(rules) {
  return rules.reduce((grammar, rule) => {
    grammar[rule.name] = { type: rule.type };
    if (rule.data !== undefined) {
      grammar[rule.name].data = rule.data;
    }
    return grammar;
  }, {});
}

function transformSyntactic(rules) {
  const result = [];
  for (const rule of rules) {
    for (const production of rule.data) {
      let obj;
      if (production.type === 'sequence') {
        obj = {
          name: rule.name,
          production: production.data,
        };
      } else {
        obj = {
          name: rule.name,
          production: [production],
        };
      }
      log.info(JSON.stringify(obj));
      result.push(obj);
    }
  }
  return result;
}

class Transpiler {
  constructor(options) {
    this.options_ = options;
    switch (options.grammarType) {
    case 'lexical':
      this.passes_ = [
        addLexicalRules,
        rewriteReservedWord,
        rewritePunctuator,
        expandOptionals,
        expandParameterizedRules,
        translateRules,
        addSourceCharacter,
        mergeUnicodeSets,
        simplify,
        transform,
      ];
      break;
    case 'syntactic':
      this.passes_ = [
        rewriteIdentifierRule,
        expandOptionals,
        expandParameterizedRules,
        translateRules,
        processLookaheads,
        addLiterals,
        transformSyntactic,
      ];
      break;
    default:
      unreachable();
    }
  }

  async transpile() {
    const esgrammar = await readAllText(Deno.stdin);
    let rules = readRules(esgrammar);
    for (const pass of this.passes_) {
      rules = pass(rules, this.options_);
    }
    return rules;
  }
}

function readRules(esgrammar) {
  const STATE_RULE = 0;
  const STATE_MEMBER = 1;

  let state = STATE_RULE;
  let name;
  let values;
  let oneOf;

  const rules = [];
  for (const line of esgrammar.split('\n')) {
    if (state === STATE_RULE) {
      if (line.trim().length === 0) {
        continue;
      }
      const parts = line.trim().split(/\s*[:]+\s*/u);
      name = parts.shift();
      if (parts[0] !== undefined && parts[0].startsWith('one of')) {
        oneOf = true;
      } else {
        oneOf = false;
      }
      values = [];
      state = STATE_MEMBER;
    } else if (state === STATE_MEMBER) {
      let trimed = line.trim();
      if (trimed.length === 0) {
        if (name === 'CodePoint') {
          // Special case: CodePoint
          rules.push({
            name,
            values: [
              'HexDigit',
              'HexDigit HexDigit',
              'HexDigit HexDigit HexDigit',
              'Hex4Digits',
              'HexDigit Hex4Digits',
              '`10` Hex4Digits',
              '`0` CodePoint',
            ],
          });
        } else if (name === 'NotCodePoint') {
          // Special case: NotCodePoint
          rules.push({
            name,
            values: [
              'NonZeroHexDigit NonZeroHexDigit Hex4Digits',
              'HexDigit NotCodePoint',
            ],
          });
        } else {
          rules.push({ name, values });
        }
        state = STATE_RULE;
        continue;
      }
      if (oneOf) {
        values = values.concat(trimed.split(/\s+/u));
      } else {
        // A production rule in the syntactic grammar ends with '#<name>' which
        // may be used for generating an anchor to it.  Remove '#<name>'.
        const pos = trimed.search(/#\w+$/);
        if (pos !== -1) {
          trimed = trimed.slice(0, pos).trim();
        }
        values.push(trimed);
      }
    }
  }

  return rules;
}

function addLexicalRules(rules) {
  // Additional rules.
  rules.push({
    name: 'NonZeroHexDigit',
    values: ['HexDigit but not `0`'],
  });
  rules.push({
    name: 'WhiteSpaceSequence',
    values: ['WhiteSpace WhiteSpaceSequence?'],
  });

  return rules;
}

function rewriteReservedWord(rules) {
  log.debug('Rewriting ReservedWord...');
  const rule = rules.find((rule) => rule.name === 'ReservedWord');
  assert(rule !== undefined);
  const values = rule.values;
  rule.values = [];
  for (const reserved of values) {
    rule.values.push(reserved.slice(1, -1).toUpperCase());
    rules.push({
      name: reserved.slice(1, -1).toUpperCase(),
      values: [reserved],
    });
  }
  const ADDITIONAL = [
    'async', 'from', 'get', 'meta', 'of', 'set', 'target',
    // For the strict mode
    'let', 'static', 'implements', 'interface', 'packege', 'private', 'protected', 'public',
  ];
  for (const word of ADDITIONAL) {
    rule.values.push(word.toUpperCase());
    rules.push({
      name: word.toUpperCase(),
      values: [`\`${word}\``],
    });
  }
  return rules;
}

const PUNCTUATORS = {
  '?.': 'OPTIONAL_CHAINING',
  '{': 'LBRACE',
  '}': 'RBRACE',
  '[': 'LBRACK',
  ']': 'RBRACK',
  '(': 'LPAREN',
  ')': 'RPAREN',
  '.': 'DOT',
  '...': 'ELLIPSIS',
  ';': 'SEMI_COLON',
  ',': 'COMMA',
  '<': 'LT',
  '>': 'GT',
  '<=': 'LTE',
  '>=': 'GTE',
  '==': 'EQ',
  '!=': 'NE',
  '===': 'EQ_STRICT',
  '!==': 'NE_STRICT',
  '+': 'ADD',
  '-': 'SUB',
  '*': 'MUL',
  '/': 'DIV',
  '%': 'MOD',
  '**': 'EXP',
  '++': 'INC',
  '--': 'DEC',
  '<<': 'SHL',
  '>>': 'SAR',
  '>>>': 'SHR',
  '&': 'BIT_AND',
  '|': 'BIT_OR',
  '^': 'BIT_XOR',
  '!': 'NOT',
  '~': 'BIT_NOT',
  '&&': 'AND',
  '||': 'OR',
  '??': 'NULLISH',
  '?': 'CONDITIONAL',
  ':': 'COLON',
  '=': 'ASSIGN',
  '+=': 'ADD_ASSIGN',
  '-=': 'SUB_ASSIGN',
  '*=': 'MUL_ASSIGN',
  '/=': 'DIV_ASSIGN',
  '%=': 'MOD_ASSIGN',
  '**=': 'EXP_ASSIGN',
  '<<=': 'SHL_ASSIGN',
  '>>=': 'SAR_ASSIGN',
  '>>>=': 'SHR_ASSIGN',
  '&=': 'BIT_AND_ASSIGN',
  '|=': 'BIT_OR_ASSIGN',
  '^=': 'BIT_XOR_ASSIGN',
  '&&=': 'AND_ASSIGN',
  '||=': 'OR_ASSIGN',
  '??=': 'NULLISH_ASSIGN',
  '=>': 'ARROW',
};

function rewritePunctuator(rules) {
  log.debug('Rewriting Punctuators...');
  const optionalChaining = rules.find((rule) => rule.name === 'OptionalChainingPunctuator');
  rules.push({
    name: 'OPTIONAL_CHAINING',
    values: optionalChaining.values,
  });
  optionalChaining.values = ['OPTIONAL_CHAINING'];

  const otherPunctuator = rules.find((rule) => rule.name === 'OtherPunctuator');
  otherPunctuator.values.forEach((value) => {
    rules.push({
      name: PUNCTUATORS[value.slice(1, -1)],
      values: [value]
    });
  });
  otherPunctuator.values = otherPunctuator.values.map((value) => {
    return PUNCTUATORS[value.slice(1, -1)];
  });

  const divPunctuator = rules.find((rule) => rule.name === 'DivPunctuator');
  divPunctuator.values.forEach((value) => {
    rules.push({
      name: PUNCTUATORS[value.slice(1, -1)],
      values: [value],
    });
  });
  divPunctuator.values = divPunctuator.values.map((value) => {
    return PUNCTUATORS[value.slice(1, -1)];
  });

  const rightBracePunctuator = rules.find((rule) => rule.name === 'RightBracePunctuator');
  rightBracePunctuator.values.forEach((value) => {
    rules.push({
      name: PUNCTUATORS[value.slice(1, -1)],
      values: [value],
    });
  });
  rightBracePunctuator.values = rightBracePunctuator.values.map((value) => {
    return PUNCTUATORS[value.slice(1, -1)];
  });

  return rules;
}

function rewriteIdentifierRule(rules) {
  log.debug('Rewriting Identifier rule...');
  const rule = rules.find((rule) => rule.name === 'Identifier');
  assert(rule !== undefined);
  assert(rule.values[0] === 'IdentifierName but not ReservedWord');
  // A generated lexer recognizes the reserved words as separate tokens.
  rule.values = ['IdentifierName'];
  return rules;
}

function expandOptionals(rules) {
  log.debug('Expanding optionals...');
  const expanded = [];
  for (const rule of rules) {
    const values = [];
    let hasOptionals = false;
    for (const value of rule.values) {
      // A parameter list contains spaces like below:
      //
      //  AssignmentRestProperty[?Yield, ?Await]?
      //
      const parts = value.split(/(?<!,)\s+/u);
      let patterns = [[]];
      for (let part of parts) {
        if (part.endsWith('?')) {
          hasOptionals = true;
          const clone = patterns.map((pattern) => Array.from(pattern));
          part = part.slice(0, -1);
          clone.forEach((pattern) => pattern.push(part));
          patterns = patterns.concat(clone);
        } else {
          patterns.forEach((pattern) => pattern.push(part));
        }
      }
      patterns.forEach((pattern) => {
        if (pattern.length === 0) {
          values.push('[empty]');
        } else {
          values.push(pattern.join(' '));
        }
      });
    }
    if (hasOptionals) {
      log.debug(`  ${rule.name}`);
    }
    expanded.push({
      name: rule.name,
      values,
    });
  }
  return expanded;
}

function expandParameterizedRules(rules) {
  log.debug('Expanding parameterized rules...');
  const expanded = [];

  for (const rule of rules) {
    if (rule.name.endsWith(']')) {
      log.debug(`  ${rule.name}`);
      const [name, paramList] = rule.name.split(/[\[\]]/u);
      const params = paramList.split(', ');
      const combinations = buildParameterCombinations(params);
      for (const combination of combinations) {
        log.debug(`    combination:  ${JSON.stringify(combination)}`);
        const values = [];
        for (let value of rule.values) {
          let valueToBeExpanded;
          if (value.startsWith('[+')) {
            const pos = value.indexOf(']');
            assert(pos !== -1);
            const param = value.slice(2, pos);
            const remaining = value.slice(pos + 1).trim();
            if (!combination.includes(param)) {
              log.debug(`      ${value} ->`);
              continue;
            }
            valueToBeExpanded = remaining;
          } else if (value.startsWith('[~')) {
            const pos = value.indexOf(']');
            assert(pos !== -1);
            const param = value.slice(2, pos);
            const remaining = value.slice(pos + 1).trim();
            if (combination.includes(param)) {
              log.debug(`      ${value} ->`);
              continue;
            }
            valueToBeExpanded = remaining;
          } else {
            valueToBeExpanded = value;
          }
          const expandedValue = expandParameterizedValue(valueToBeExpanded, combination);
          log.debug(`      ${value}`);
          log.debug(`       -> ${expandedValue}`);
          values.push(expandedValue);
        }
        if (values.length > 0) {
          expanded.push({
            name: expandRuleName(name, combination),
            values,
          });
        }
      }
    } else {
      expanded.push({
        name: rule.name,
        values: rule.values.map(expandParameterizedValue),
      });
    }
  }
  return expanded;
}

function buildParameterCombinations(params) {
  assert(params.length > 0);
  const param = params[0];
  if (params.length === 1) {
    return [[], [param]];
  }
  const remaining = params.slice(1);
  const combinations = buildParameterCombinations(remaining);
  return combinations.concat(combinations.map((params) => [param].concat(params)));
}

function expandRuleName(name, combination) {
  return [name, ...combination].join('_');
}

function expandParameterizedValue(value, combination) {
  let expanded = '';
  for (;;) {
    let pos = value.search(/\[[?+~]/);
    if (pos === -1) {
      expanded = expanded + value;
      break;
    }
    expanded = expanded + value.slice(0, pos);
    value = value.slice(pos);
    pos = value.indexOf(']');
    assert(pos !== -1);
    const patterns = value
          .slice(1, pos)  // remove '[' and ']'
          .split(', ');
    const suffix = expandSuffixPatterns(patterns, combination);
    if (suffix.length > 0) {
      expanded = expanded + '_' + suffix;
    }
    value = value.slice(pos + 1);  // remove '[...]'
  }
  return expanded;
}

function expandSuffixPatterns(patterns, combination) {
  let params = [];
  for (const pattern of patterns) {
    if (pattern.startsWith('~')) {
      continue;
    }
    if (pattern.startsWith('+')) {
      params.push(pattern.slice(1))
      continue;
    }
    if (pattern.startsWith('?')) {
      const param = pattern.slice(1);
      if (combination.includes(param)) {
        params.push(param);
      }
    }
  }
  return params.join('_');
}

function translateRules(rules, options) {
  const grammar = [];
  for (const rule of rules) {
    log.debug(`Translating ${rule.name}...`);
    grammar.push({
      type: 'one-of',
      name: rule.name,
      data: rule.values.map((value) => translateProduction(value, options)),
    });
  }
  return grammar;
}

function translateProduction(production, options) {
  log.debug(`  ${production}`);

  // Special case: ID_Start
  if (production === '> any Unicode code point with the Unicode property “ID_Start”') {
    // TODO:
    // return {
    //   type: 'unicode-set',
    //   data: [{ type: 'property', data: 'ID_Start' }],
    // };
    return {
      type: 'unicode-set',
      data: [
        { type: 'span', data: ['a', 'z'] },
        { type: 'span', data: ['A', 'Z'] },
        { type: 'char', data: '$' },
        { type: 'char', data: '_' },
      ]
    };
  }

  // Special case: ID_Continue
  if (production === '> any Unicode code point with the Unicode property “ID_Continue”') {
    // TODO:
    // return {
    //   type: 'unicode-set',
    //   data: [{ type: 'property',  data: 'ID_Continue' }],
    // };
    return {
      type: 'unicode-set',
      data: [
        { type: 'span', data: ['0', '9'] },
        { type: 'span', data: ['a', 'z'] },
        { type: 'span', data: ['A', 'Z'] },
        { type: 'char', data: '$' },
        { type: 'char', data: '_' },
      ]
    };
  }

  // Special case: X but not one of ...
  if (production.includes('but not one of')) {
    production = production.replace('but not one of', '');
    production = production.replaceAll(' or', '');
    const [base, ...excludes] = production.split(/\s+/u);
    return {
      type: 'unicode-set',
      data: [
        { type: 'non-terminal', data: base },
        ...excludes.map((exclude) => {
          if (exclude.startsWith('`')) {
            return { type: 'exclude', data: exclude.slice(1, -1) };
          }
          return { type: 'exclude', data: exclude };
        }),
      ]
    };
  }

  // Special case: X but not ...
  if (production.includes('but not')) {
    production = production.replace('but not', '');
    const [base, ...excludes] = production.split(/\s+/u);
    return {
      type: 'unicode-set',
      data: [
        { type: 'non-terminal', data: base },
        ...excludes.map((exclude) => {
          if (exclude.startsWith('`')) {
            return { type: 'exclude', data: exclude.slice(1, -1) };
          }
          return { type: 'exclude', data: exclude };
        }),
      ]
    };
  }

  // Special case: [no LineTerminator here]
  production = production.replaceAll(
    '[no LineTerminator here]', '[no-line-terminator]');

  let seq = [];
  const items = production.split(/\s+/u);
  while (items.length > 0) {
    let item = items.shift();
    if (item.startsWith('`')) {
      const str = item.slice(1, -1);
      if (options.grammarType === 'lexical') {
        // We assume that `str` contains only ASCII characters.
        if (str.length === 1) {
          seq.push({
            type: 'unicode-set',
            data: [{ type: 'char', data: str }],
          });
        } else {
          seq.push({ type: 'word', data: str });
        }
      } else {
        assertEquals(options.grammarType, 'syntactic');
        let token = PUNCTUATORS[str];
        if (token === undefined) {
          token = str.toUpperCase();
        }
        seq.push({
          type: 'token',
          data: token,
        });
      }
    } else if (item.startsWith('<')) {
      assertEquals(options.grammarType, 'lexical');
      seq.push({
        type: 'unicode-set',
        data: [{ type: 'built-in', data: item.slice(1, -1) }],
      });
    } else if (item === '[lookahead') {
      seq = seq.concat(translateLookahead(items, options));
    } else if (item === '[no-line-terminator]') {
      //seq.push({ type: 'no-line-terminator' });  TODO
    } else if (item === '[empty]') {
      seq.push({ type: 'empty' });
    } else if (options.tokens?.includes(item)) {
      seq.push({ type: 'token', data: item });
    } else {
      seq.push({ type: 'non-terminal', data: item });
    }
  }

  if (seq.length === 1) {
    return seq[0];
  }
  return { type: 'sequence', data: seq };
}

function translateLookahead(items, options) {
  let op = items.shift();
  let target = items.shift();
  let values;
  if (target === '{') {
    values = [];
    let seq = [];
    target = items.shift();
    for (;;) {
      if (target === '}]') {
        if (seq.length > 0) {
          values.push(seq);
        }
        break;
      }
      if (target.endsWith(',')) {
        seq.push(target.slice(0, -1));
        values.push(seq);
        seq = [];
      } else {
        seq.push(target);
      }
      target = items.shift();
    }
  } else {
    const seq = [];
    for (;;) {
      if (target.endsWith(']')) {
        seq.push(target.slice(0, -1));  // remove the last ']'
        break;
      } else {
        seq.push(target);
      }
      target = items.shift();
    }
    values = [seq];
  }
  switch (op) {
  case '=':
    return translateLookaheadSet(values, false, options);
  case '!=':
    return translateLookaheadSet(values, true/* negate */, options);
  case '\u2208':
    return translateLookaheadSet(values, false, options);
  case '\u2209':
    return translateLookaheadSet(values, true/* negate */, options);
  default:
    log.error(`translateLookahead: Unknown op: U+${op.codePointAt(0).toString(16)}`);
    Deno.exit(1);
  }
}

function translateLookaheadSet(values, negate, options) {
  const set = [];
  for (let seq of values) {
    const data = seq.filter((value) => {
      return value !== '[no-line-terminator]';  // TODO
    }).map((value) => {
      if (value.startsWith('`')) {
        if (options.grammarType === 'lexical') {
          return { type: 'char', data: value.slice(1, -1) };
        } else {
          assertEquals(options.grammarType, 'syntactic');
          const str = value.slice(1, -1);
          let token = PUNCTUATORS[str];
          if (token === undefined) {
            token = str.toUpperCase();
          }
          return  { type: 'token', data: token };
        }
      } else if (value.startsWith('<')) {
        assertEquals(options.grammarType, 'lexical');
        return { type: 'built-in', data: value.slice(1, -1) };
      } else if (value === '[no-line-terminator]') {
        assertEquals(options.grammarType, 'syntactic');
        return { type: 'no-line-terminator' };
      } else {
        assertEquals(options.grammarType, 'lexical');
        return { type: 'non-terminal', data: value };
      }
    });
    if (data.length === 1) {
      set.push(data[0]);
    } else {
      set.push({ type: 'sequence', data });
    }
  }
  log.debug(JSON.stringify(set));
  return {
    type: 'lookahead',
    data: {
      patterns: set,
      negate,
    },
  };
}

function addSourceCharacter(rules) {
  log.debug(`Adding SourceCharacter...`);
  return [
    {
      name: 'SourceCharacter',
      type: 'any',
    },
    ...rules
  ];
}

function mergeUnicodeSets(rules) {
  for (const rule of rules) {
    if (rule.type === 'one-of' &&
        rule.data.every((item) => item.type === 'unicode-set')) {
      log.debug(`Merging unicode sets in ${rule.name}...`);
      let data = rule.data.reduce((data, item) => data.concat(item.data), []);
      rule.type = 'unicode-set';
      rule.data = data;
    }
  }
  return rules;
}

function processLookaheads(rules) {
  const context = {
    ruleMap: {},
    newRules: [],
  };
  for (const rule of rules) {
    context.ruleMap[rule.name] = rule;
  }
  for (const rule of rules) {
    log.debug(`Processing lookaheads in ${rule.name}...`);
    rule.data.forEach((production, index) => {
      return processLookaheadsInProduction(context, rule.name, production, index);
    });
  }
  return rules;
}

function processLookaheadsInProduction(context, name, production, index) {
  switch (production.type) {
  case 'sequence':
    for (const symbol of production.data) {
      switch (symbol.type) {
      case 'lookahead':
        const data = symbol.data.patterns.map((symbol) => {
          switch (symbol.type) {
          case 'token':
            return [symbol.data];
          case 'sequence':
            return symbol.data.map((data) => data.data);
          }
        });
        if (symbol.data.negate) {
          symbol.data = { type: 'exclude', data };
        } else {
          symbol.data = { type: 'include', data };
        }
        break;
      }
    }
  }
}

function rewriteProduction(context, name, lookahead) {
}

function matchPrefix(seq, prefix) {
  // TODO: logging
  const prefixList = prefix.data.patterns.map((sym) => {
    if (sym.type === 'token') {
      return sym.data;
    }
    assertEquals(sym.type, 'sequence');
    return sym.data.map((s) => s.data).join(' ');
  });

  const tokens= [];
  for (const sym of seq) {
    if (sym.type !== 'token') {
      break;
    }
    tokens.push(sym.data);
  }

  const tokenSeq = tokens.join(' ');
  if (prefix.data.negate) {
    return prefixList.every((prefix) => {
      if (prefix.length < tokenSeq.length) {
        return !tokenSeq.startsWith(prefix);
      }
      return !prefix.startsWith(tokenSeq);
    });
  } else {
    return prefixList.some((prefix) => {
      if (prefix.length < tokenSeq.length) {
        return tokenSeq.startsWith(prefix);
      }
      return prefix.startsWith(tokenSeq);
    });
  }
}

function simplify(rules) {
  for (const rule of rules) {
    if (rule.type === 'one-of' && rule.data.length === 1) {
      log.debug(`Simplify ${rule.name}...`);
      rule.type = rule.data[0].type;
      if (rule.data[0] !== undefined) {
        rule.data = rule.data[0].data;
      }
    }
  }
  return rules;
}

function addLiterals(rules) {
  rules.push({
    name: 'NullLiteral',
    type: 'one-of',
    data: [
      { type: 'token', data: 'NULL' },
    ]
  });
  rules.push({
    name: 'BooleanLiteral',
    type: 'one-of',
    data: [
      { type: 'token', data: 'TRUE' },
      { type: 'token', data: 'FALSE' },
    ]
  });
  return rules;
}

function printYaml(rules) {
  console.log(HEADER);
  console.log('');
  console.log(yaml.stringify(rules).trim());
}

if (import.meta.main) {
  const { options, args } = await parseCommand({
    doc: DOC,
    conv: async (name, value) => {
      switch (name) {
      case '--tokens':
        if (value) {
          return JSON.parse(await Deno.readTextFile(value));
        }
        return value;
      default:
        return value;
      }
    },
  });
  Deno.exit(await run(options));
}

// tests

setup(PROGNAME, 'DEBUG');

Deno.test('expandRuleName', () => {
  assertEquals(expandRuleName('R', []), 'R');
  assertEquals(expandRuleName('R', ['A']), 'R_A');
  assertEquals(expandRuleName('R', ['A', 'B']), 'R_A_B');
});

Deno.test('expandSuffixPatterns', () => {
  assertEquals(expandSuffixPatterns(['+A', '~B', '?C'], []), 'A');
  assertEquals(expandSuffixPatterns(['+A', '~B', '?C'], ['C']), 'A_C');
});

Deno.test('expandParameterizedValue', () => {
  const VALUE = 'R1[+A] R2[~B] R3[?C] R4[+A, ~B, ?C] R5'
  assertEquals(
    expandParameterizedValue(VALUE, []),
    'R1_A R2 R3 R4_A R5'
  );
  assertEquals(
    expandParameterizedValue(VALUE, ['C']),
    'R1_A R2 R3_C R4_A_C R5'
  );
});
