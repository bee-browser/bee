// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated by:
// {{@command}}

use super::Error;
use super::SourceCursor;
use super::Token;
use crate::lexer::tokens::TokenKind;
use crate::lexer::TokenFlags;

pub fn recognize<'a>(cursor: &SourceCursor<'a>) -> Result<Token<'a>, Error> {
    let mut token = Token::default();

    let mut state = State::default();
    tracing::trace!(opcode = "init", ?state);

    let mut has_line_terminators = false;
    let mut lexeme_end = 0;
    let mut chars = cursor.chars();
    loop {
        let (pos, mut unicode_set) = match chars.next() {
            Some((i, ch)) => {
                // TODO: The current implementation is not slow, but using a table may be faster.
                // We can use UnicodeSet::0 as an index of the table.
                // We assume that line terminators and others must not be contained in the same charclass.
                match ch {
                    '\u{000A}' | '\u{000D}' | '\u{2028}' | '\u{2029}' => has_line_terminators = true,
                    _ => (),
                }
                (cursor.pos() + i, UnicodeSet::from(ch))
            }
            None => (cursor.len(), UnicodeSet::EOF),
        };

        let mut next = state.next_state(&unicode_set);
        if next.is_invalid() {
            // A dirty hack for handling ID_Start and ID_Continue.
            //
            // TODO: Support Unicode properties including ID_Start and ID_Continue in
            // `bee_dfagen::unicode::UnicodeSet`.
            if let Some(ch) = unicode_set.1 {
                match state.check_id_start_continue() {
                    CheckIdStartContinue::CheckIdStart => {
                        if unicode_id_start::is_id_start(ch) {
                            unicode_set.0 = UnicodeSet::from('z').0;
                            next = state.next_state(&unicode_set);
                        }
                    }
                    CheckIdStartContinue::CheckIdContinue => {
                        if unicode_id_start::is_id_continue(ch) {
                            unicode_set.0 = UnicodeSet::from('z').0;
                            next = state.next_state(&unicode_set);
                        }
                    }
                    CheckIdStartContinue::None => (),
                }
            }
        }
        tracing::trace!(opcode = "next", state = ?next, ?unicode_set, pos);
        if next.is_invalid() {
            if token.kind != TokenKind::Eof {
                break;
            }
            if unicode_set == UnicodeSet::EOF {
                break;
            }
            return Err(Error::UnexpectedCharacter);
        }
        state = next;
        if !state.lookahead() {
            if let Some(ch) = unicode_set.1 {
                lexeme_end = pos + ch.len_utf8();
            }
        }
        if let Some(kind) = state.accept() {
            token.lexeme = cursor.lexeme(lexeme_end);
            token.kind = kind;
            if has_line_terminators {
                token.flags |= TokenFlags::HAS_LINE_TERMINATORS;
            }
            tracing::trace!(opcode = "accept", ?token.kind, token.lexeme);
        }
    }

    Ok(token)
}

{{#each unicodeSetLabels}}
// UnicodeSet({{@index}}): {{this}}
{{/each}}
#[derive(Clone, Copy, Debug, PartialEq)]
struct UnicodeSet(u8, Option<char>);

impl UnicodeSet {
    const EOF: Self = UnicodeSet({{length unicodeSets}}, None);
}

impl From<char> for UnicodeSet {
    fn from(ch: char) -> Self {
        let c = ch as usize;
        if c < 128 {
            return UnicodeSet(ASCII_TABLE[c], Some(ch));
        }
        {{#each nonAsciiList}}
        {{#if span}}
        if c >= {{firstCodePoint}} && c <= {{lastCodePoint}} {
            return UnicodeSet({{unicodeSet}}, Some(ch));
        }
        {{else}}
        if c == {{firstCodePoint}} {
            return UnicodeSet({{unicodeSet}}, Some(ch));
        }
        {{/if}}
        {{/each}}
        UnicodeSet({{length unicodeSets}}, Some(ch))
    }
}

const ASCII_TABLE: [u8; 128] = {{json asciiTable}};

#[derive(Clone, Copy, Debug, Default)]
struct State(u16);

impl State {
    #[inline(always)]
    fn is_invalid(&self) -> bool {
        self.0 == {{numStates}}
    }

    #[inline(always)]
    fn next_state(&self, unicode_set: &UnicodeSet) -> State {
        State(TRANSITION_TABLE[self.0 as usize][unicode_set.0 as usize])
    }

    #[inline(always)]
    fn lookahead(&self) -> bool {
        LOOKAHEAD_TABLE[self.0 as usize]
    }

    #[inline(always)]
    fn accept(&self) -> Option<TokenKind> {
        ACCEPT_TABLE[self.0 as usize]
    }

    #[inline(always)]
    fn check_id_start_continue(&self) -> CheckIdStartContinue {
        CHECK_ID_START_CONTINUE_TABLE[self.0 as usize]
    }
}

const TRANSITION_TABLE: [[u16; {{numTransitions}}]; {{numStates}}] = [
    {{#each states}}
    // State({{@index}})
    {{#each labels}}
    //   {{this}}
    {{/each}}
    {{#if transitionLabels}}
    // Transitions
    {{#each transitionLabels}}
    //   {{this}}
    {{/each}}
    {{/if}}
    {{json transitions}},
    {{/each}}
];

const ACCEPT_TABLE: [Option<TokenKind>; {{numStates}}] = [
    {{#each states}}
    {{#if accept}}
    Some(TokenKind::{{pascalCase accept}}), // State({{@index}})
    {{else}}
    None, // State({{@index}})
    {{/if}}
    {{/each}}
];

const LOOKAHEAD_TABLE: [bool; {{numStates}}] = [
    {{#each states}}
    {{#if lookahead}}
    true, // State({{@index}})
    {{else}}
    false, // State({{@index}})
    {{/if}}
    {{/each}}
];

#[derive(Clone, Copy)]
#[repr(u8)]
enum CheckIdStartContinue {
    None,
    CheckIdStart,
    CheckIdContinue,
}

const CHECK_ID_START_CONTINUE_TABLE: [CheckIdStartContinue; {{numStates}}] = [
    {{#each states}}
    {{#if checkIdStart}}
    CheckIdStartContinue::CheckIdStart,
    {{else if checkIdContinue}}
    CheckIdStartContinue::CheckIdContinue,
    {{else}}
    CheckIdStartContinue::None,
    {{/if}}
    {{/each}}
];
