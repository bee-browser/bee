// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated by:
// bee-tools-codegen.js --no-escape --input-stdin whitespace.rs.hbs

use super::*;

impl<T> TreeBuilder<T>
where
    T: DomTreeBuilder,
{
    pub fn handle_whitespace(&mut self, mut text: Text<'_>) -> Control {
        debug_assert!(!text.data.is_empty());
        if self.ignore_lf && text.data.starts_with('\n') {
            tracing::debug!(ignore_lf = true);
            text.data = text.data.strip_prefix('\n').unwrap();
            self.ignore_lf = false;
        }
        if text.data.is_empty() {
            return Control::Continue;
        }
        loop {
            let span = tracing::debug_span!("handle_whitespace", mode = ?self.mode);
            let _enter = span.enter();
            match self.mode {
                mode!(Initial, BeforeHtml, BeforeHead) => {
                    let ctrl = {
                        // Ignore the token.
                        tracing::debug!("Ignore the token");
                        Control::Continue
                    };
                    match ctrl {
                        Control::Reprocess => continue,
                        _ => break,
                    }
                }
                mode!(
                    InHead,
                    InHeadNoscript,
                    AfterHead,
                    Text,
                    InColumnGroup,
                    InSelect,
                    InSelectInTable,
                    InFrameset,
                    AfterFrameset
                ) => {
                    let ctrl = {
                        self.append_text(text.data);
                        Control::Continue
                    };
                    match ctrl {
                        Control::Reprocess => continue,
                        _ => break,
                    }
                }
                mode!(
                    InBody,
                    InCaption,
                    InCell,
                    InTemplate,
                    AfterBody,
                    AfterAfterBody,
                    AfterAfterFrameset
                ) => {
                    let ctrl = {
                        self.reconstruct_active_formatting_elements();
                        self.append_text(text.data);
                        Control::Continue
                    };
                    match ctrl {
                        Control::Reprocess => continue,
                        _ => break,
                    }
                }
                mode!(InTable, InTableBody, InRow) => {
                    let ctrl = {
                        if self.context().is_one_of_html_elements(&tags![
                            Table, Tbody, Template, Tfoot, Thead, Tr
                        ]) {
                            self.append_text_if_exists();
                            self.pending_table_text.clear();
                            self.pending_table_text_contains_non_whitespace = false;
                            self.save_and_switch_to(mode!(InTableText));
                            Control::Reprocess
                        } else {
                            // TODO: Parse error.
                            tracing::debug!("Parse error");
                            self.enable_foster_parenting();
                            let ctrl = {
                                self.reconstruct_active_formatting_elements();
                                self.append_text(text.data);
                                Control::Continue
                            };
                            self.disable_foster_parenting();
                            ctrl
                        }
                    };
                    match ctrl {
                        Control::Reprocess => continue,
                        _ => break,
                    }
                }
                mode!(InTableText) => {
                    let ctrl = {
                        self.pending_table_text.push_str(text.data);
                        Control::Continue
                    };
                    match ctrl {
                        Control::Reprocess => continue,
                        _ => break,
                    }
                }
            }
        }
        Control::Continue
    }
}
