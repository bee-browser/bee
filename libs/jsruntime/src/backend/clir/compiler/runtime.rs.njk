// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{ template }}

use std::cell::OnceCell;

use cranelift::codegen::ir;
use cranelift::codegen::isa;
use cranelift_jit::JITBuilder;
use cranelift_module::FuncId;
use cranelift_module::Linkage;
use cranelift_module::Module;

use crate::backend::RuntimeFunctions;

pub fn register_symbols(builder: &mut JITBuilder, funcs: &RuntimeFunctions) {
    {%- for func in data.functions %}
    builder.symbol("runtime_{{ func.name }}", funcs.{{ func.name }} as *const u8);
    {%- endfor %}
}

#[derive(Clone)]
pub struct RuntimeFunctionIds {
    // TODO(feat): if cfg!(feature = "libm")
    fmod: FuncId,
    // TODO(feat): if cfg!(feature = "libm")
    pow: FuncId,

    {%- for func in data.functions %}
    #[allow(unused)]
    {{ func.name }}: FuncId,
    {%- endfor %}
}

pub fn make_lambda_signature<T: Module>(module: &mut T) -> ir::Signature {
    let mut sig = module.make_signature();
    let addr_type = module.target_config().pointer_type();

    // runtime: *mut c_void
    sig.params.push(ir::AbiParam::new(addr_type));
    // context: *mut c_void
    sig.params.push(ir::AbiParam::new(addr_type));
    // args: u16
    sig.params.push(ir::AbiParam::new(ir::types::I16));
    // argv: *mut Value
    sig.params.push(ir::AbiParam::new(addr_type));
    // retv: *mut Value
    sig.params.push(ir::AbiParam::new(addr_type));

    // #[repr(u32)] Status
    sig.returns.push(ir::AbiParam::new(ir::types::I32));

    sig
}

pub fn declare_functions<T: Module>(module: &mut T) -> RuntimeFunctionIds {
    let addr_type = module.target_config().pointer_type();

    // TODO(feat): if cfg!(feature = "libm")
    let name = "fmod";
    let mut sig = module.make_signature();
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.returns.push(ir::AbiParam::new(ir::types::F64));
    let fmod = module.declare_function(name, Linkage::Import, &sig).unwrap();

    // TODO(feat): if cfg!(feature = "libm")
    let name = "pow";
    let mut sig = module.make_signature();
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.returns.push(ir::AbiParam::new(ir::types::F64));
    let pow = module.declare_function(name, Linkage::Import, &sig).unwrap();
    {%- for func in data.functions %}

    let name = "runtime_{{ func.name }}";
    let mut sig = module.make_signature();
    {%- for arg in func.args %}
    sig.params.push(ir::AbiParam::new({{ arg.clir_type }}));
    {%- endfor %}
    {%- if func.clir_ret %}
    sig.returns.push(ir::AbiParam::new({{ func.clir_ret }}));
    {%- endif %}
    let {{ func.name }} = module.declare_function(name, Linkage::Import, &sig).unwrap();
    {%- endfor %}

    RuntimeFunctionIds {
        fmod,
        pow,
        {%- for func in data.functions %}
        {{ func.name }},
        {%- endfor %}
    }
}

pub struct RuntimeFunctionCache {
    ids: RuntimeFunctionIds,
    target_config: isa::TargetFrontendConfig,

    // TODO(feat): if cfg!(feature = "libm")
    #[allow(unused)]
    fmod: OnceCell<ir::FuncRef>,
    // TODO(feat): if cfg!(feature = "libm")
    #[allow(unused)]
    pow: OnceCell<ir::FuncRef>,

    {%- for func in data.functions %}
    #[allow(unused)]
    {{ func.name }}: OnceCell<ir::FuncRef>,
    {%- endfor %}
}

impl RuntimeFunctionCache {
    pub fn new(
        ids: RuntimeFunctionIds,
        target_config: isa::TargetFrontendConfig,
    ) -> Self {
        Self {
            ids,
            target_config,
            // TODO(feat): if cfg!(feature = "libm")
            fmod: Default::default(),
            // TODO(feat): if cfg!(feature = "libm")
            pow: Default::default(),
            {%- for func in data.functions %}
            {{ func.name }}: Default::default(),
            {%- endfor %}
        }
    }

    // TODO(feat): if cfg!(feature = "libm")
    #[allow(unused)]
    pub fn get_fmod(&self, func: &mut ir::Function) -> ir::FuncRef {
        *self.fmod.get_or_init(|| {
            let mut sig = ir::Signature::new(self.target_config.default_call_conv);
            sig.params.push(ir::AbiParam::new(ir::types::F64));
            sig.params.push(ir::AbiParam::new(ir::types::F64));
            sig.returns.push(ir::AbiParam::new(ir::types::F64));
            let signature = func.import_signature(sig);
            let name = ir::UserExternalName::new(0, self.ids.fmod.as_u32());
            let name = func.declare_imported_user_function(name);
            let name = ir::ExternalName::user(name);
            func.import_function(ir::ExtFuncData {
                name,
                signature,
                colocated: false, // Linkage::Import
            })
        })
    }

    // TODO(feat): if cfg!(feature = "libm")
    #[allow(unused)]
    pub fn get_pow(&self, func: &mut ir::Function) -> ir::FuncRef {
        *self.pow.get_or_init(|| {
            let mut sig = ir::Signature::new(self.target_config.default_call_conv);
            sig.params.push(ir::AbiParam::new(ir::types::F64));
            sig.params.push(ir::AbiParam::new(ir::types::F64));
            sig.returns.push(ir::AbiParam::new(ir::types::F64));
            let signature = func.import_signature(sig);
            let name = ir::UserExternalName::new(0, self.ids.pow.as_u32());
            let name = func.declare_imported_user_function(name);
            let name = ir::ExternalName::user(name);
            func.import_function(ir::ExtFuncData {
                name,
                signature,
                colocated: false, // Linkage::Import
            })
        })
    }
    {%- for func in data.functions %}

    #[allow(unused)]
    pub fn get_{{ func.name }}(&self, func: &mut ir::Function) -> ir::FuncRef {
        *self.{{ func.name }}.get_or_init(|| {
            let mut sig = ir::Signature::new(self.target_config.default_call_conv);
            {%- for arg in func.args %}
            sig.params.push(ir::AbiParam::new({{ arg.clir_type2 }}));
            {%- endfor %}
            {%- if func.clir_ret %}
            sig.returns.push(ir::AbiParam::new({{ func.clir_ret2 }}));
            {%- endif %}
            let signature = func.import_signature(sig);
            let name = ir::UserExternalName::new(0, self.ids.{{ func.name }}.as_u32());
            let name = func.declare_imported_user_function(name);
            let name = ir::ExternalName::user(name);
            func.import_function(ir::ExtFuncData {
                name,
                signature,
                colocated: false, // Linkage::Import
            })
        })
    }
    {%- endfor %}
}
