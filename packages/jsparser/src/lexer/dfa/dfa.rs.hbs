// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated by:
// {{@command}}

use super::SourceCursor;
use super::Token;
use super::TokenKind;

pub fn recognize<'a>(cursor: &SourceCursor<'a>) -> Token<'a> {
    let mut token = Token::default();

    let mut state = State::default();
    tracing::trace!(opcode = "init", ?state);

    let mut lexeme_end = 0;
    for (i, ch) in cursor.chars() {
        let unicode_set = match UnicodeSet::try_from(ch) {
            Ok(unicode_set) => unicode_set,
            Err(_) => {
                tracing::error!(invalid_char = ?ch, pos = cursor.pos() + i);
                break;
            }
        };
        state = state.next_state(unicode_set);
        tracing::trace!(opcode = "next", ?state, char = ?ch, ?unicode_set, pos = cursor.pos() + i);
        if state.is_invalid() {
            break;
        }
        if !state.lookahead() {
            debug_assert_eq!(lexeme_end, i);
            lexeme_end += ch.len_utf8();
        }
        if let Some(kind) = state.accept() {
            token.kind = kind;
            token.lexeme = cursor.lexeme(lexeme_end);
            tracing::trace!(opcode = "accept", ?token.kind, ?token.lexeme);
        }
    }

    token
}

#[derive(Clone, Copy, Debug)]
struct UnicodeSet(u8);

impl TryFrom<char> for UnicodeSet {
    type Error = ();

    fn try_from(ch: char) -> Result<Self, Self::Error> {
        let c = ch as usize;
        if c < 128 {
            return Ok(UnicodeSet(ASCII_TABLE[c]));
        }
        {{#each nonAsciiList}}
        {{#if span}}
        if c >= {{firstCodePoint}} && c <= {{lastCodePoint}} {
            return Ok(UnicodeSet({{unicodeSet}}));
        }
        {{else}}
        if c == {{firstCodePoint}} {
            return Ok(UnicodeSet({{unicodeSet}}));
        }
        {{/if}}
        {{/each}}
        Err(())
    }
}

const ASCII_TABLE: [u8; 128] = {{json asciiTable}};

#[derive(Clone, Copy, Debug, Default)]
struct State(u16);

impl State {
    #[inline(always)]
    fn is_invalid(&self) -> bool {
        self.0 == {{length states}}
    }

    #[inline(always)]
    fn next_state(&self, unicode_set: UnicodeSet) -> State {
        State(TRANSITION_TABLE[self.0 as usize][unicode_set.0 as usize])
    }

    #[inline(always)]
    fn lookahead(&self) -> bool {
        LOOKAHEAD_TABLE[self.0 as usize]
    }

    #[inline(always)]
    fn accept(&self) -> Option<TokenKind> {
        ACCEPT_TABLE[self.0 as usize]
    }
}

const TRANSITION_TABLE: [[u16; {{length unicodeSets}}]; {{length states}}] = [
    {{#each states}}
    // State({{@index}}):
    {{#each labels}}
    //   {{this}}
    {{/each}}
    {{#if transitionLabels}}
    // Transitions:
    {{#each transitionLabels}}
    //   {{this}}
    {{/each}}
    {{/if}}
    {{json transitions}},
    {{/each}}
];

const ACCEPT_TABLE: [Option<TokenKind>; {{length states}}] = [
    {{#each states}}
    {{#if accept}}
    Some(TokenKind::{{pascalCase accept}}), // State({{@index}})
    {{else}}
    None, // State({{@index}})
    {{/if}}
    {{/each}}
];

const LOOKAHEAD_TABLE: [bool; {{length states}}] = [
    {{#each states}}
    {{#if lookahead}}
    true, // State({{@index}})
    {{else}}
    false, // State({{@index}})
    {{/if}}
    {{/each}}
];
