html5-spec:
  # You can create the permalink to the description of each insertion mode with
  # the following format:
  #
  #   ${html5-spec.url}/commit-snapshots/${html5-spec.version}/#${modes[].ref}
  #
  url: https://html.spec.whatwg.org
  # Change the commit-hash if you update this file based on another version.
  version: 1257236bd7b301d1510bafbc072519d6355cee3f

# Manually converted definitions of tree construction rules.
# Almost all rules are the same as ones defined in the HTML5 specification.
#
# * The guard condition in the rule for `<noscript>` in the `in-head` insertion
#   mode is expanded inside the Rust code in the `run` property.
modes:
  - name: initial
    ref: the-initial-insertion-mode
    rules:
      - match: whitespace
        run: |
          {{use '$ignore-token'}}
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          if let Some("html") = doctype.name {
              {{use '$parse-error'}}
          } else if let Some(_) = doctype.public_id {
              {{use '$parse-error'}}
          } else if let Some(system_id) = doctype.system_id {
              if system_id != "about:legacy-compat" {
                  {{use '$parse-error'}}
              }
          }
          self.append_doctype(&doctype);
          self.determine_quirks_mode(&doctype);
          self.switch_to(mode!(BeforeHtml));
          Control::Continue
      - match: any
        run: |
          if !self.iframe_srcdoc {
              {{use '$parse-error'}}
          }
          self.change_quirks_mode_if_changeable(QuirksMode::Quirks);
          self.switch_to(mode!(BeforeHtml));
          Control::Reprocess

  - name: before-html
    ref: the-before-html-insertion-mode
    rules:
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: comment
        run: |
          //debug_assert!(self.writer.is_empty());
          self.insert_comment(&comment);
          Control::Continue
      - match: whitespace
        run: |
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          //debug_assert!(self.writer.is_empty());
          self.push_html_html_element(tag);
          self.switch_to(mode!(BeforeHead));
          Control::Continue
      - match: </head> </body> </html> </br>
        run: |
          {{use 'anything-else'}}
      - match: </>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          //debug_assert!(self.writer.is_empty());
          self.push_html_html_element(&Tag::with_no_attrs("html"));
          self.switch_to(mode!(BeforeHead));
          Control::Reprocess

  - name: before-head
    ref: the-before-head-insertion-mode
    rules:
      - match: whitespace
        run: |
          {{use '$ignore-token'}}
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <head>
        run: |
          self.push_html_head_element(tag);
          // TODO: Set the head element pointer to the newly created head element.
          self.switch_to(mode!(InHead));
          Control::Continue
      - match: </head> </body> </html> </br>
        run: |
          {{use 'anything-else'}}
      - match: </>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          self.push_html_head_element(&Tag::with_no_attrs("head"));
          // TODO: Set the head element pointer to the newly created head element.
          self.switch_to(mode!(InHead));
          Control::Reprocess

  - name: in-head
    ref: parsing-main-inhead
    rules:
      - match: whitespace
        run: |
          self.append_char(c);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <base> <basefont> <bgsound> <link>
        run: |
          self.push_html_{{tag_name}}_element(tag);
          self.pop_element();
          self.acknowledge_self_closing(tag);
          Control::Continue
      - match: <meta>
        run: |
          self.push_html_meta_element(tag);
          self.pop_element();
          self.acknowledge_self_closing(tag);
          // TODO: If the active speculative HTML parser is null
          Control::Continue
      - match: <title>
        run: |
          {{use '$generic-rcdata-element-parsing-algorithm'}}
      - match: <noscript>
        run: |
          if self.scripting {
              {{use '$generic-raw-text-element-parsing-algorithm'}}
          } else {
              self.push_html_noscript_element(tag);
              self.switch_to(mode!(InHeadNoscript));
              Control::Continue
          }
      - match: <noframes> <style>
        run: |
          {{use '$generic-raw-text-element-parsing-algorithm'}}
      - match: <script>
        run: |
          // TODO
          self.push_html_script_element(tag);
          self.save_and_switch_to(mode!(Text));
          Control::SwitchTo(InitialState::ScriptData, "script")
      - match: </head>
        run: |
          debug_assert!(self.context().is_html_element(tag!(Head)));
          self.pop_element();
          self.switch_to(mode!(AfterHead));
          Control::Continue
      - match: </body> </html> </br>
        run: |
          {{use 'anything-else'}}
      - match: <template>
        run: |
          self.push_html_template_element(tag);
          self.push_marker_to_active_formatting_contexts();
          self.context_mut().flags |= flags!(HasTemplateElement);
          self.frameset_ok = false;
          self.switch_to(mode!(InTemplate));
          // TODO: Push "in template" onto the stack of template insertion modes so that it is the new current template insertion mode
          Control::Continue
      - match: </template>
        run: |
          if !self.context().has_template_element() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_all_implied_tags();
              if !self.context().is_html_element(tag!(Template)) {
                  {{use '$parse-error'}}
              }
              while self.context().is_html_element(tag!(Template)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html template element
              self.pop_active_formatting_elements_up_to_marker();
              // TODO: Pop the current template insertion mode off the stack of template insertion modes.
              self.reset_insertion_mode_appropriately();
          }
          Control::Continue
      - match: <head> </>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          debug_assert!(self.context().is_html_element(tag!(Head)));
          self.pop_element();
          self.switch_to(mode!(AfterHead));
          Control::Reprocess

  - name: in-head-noscript
    ref: parsing-main-inheadnoscript
    rules:
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: </noscript>
        run: |
          debug_assert!(self.context().is_html_element(tag!(Noscript)));
          self.pop_element();
          debug_assert!(self.context().is_html_element(tag!(Head)));
          self.switch_to(mode!(InHead));
          Control::Continue
      - match: >-
          whitespace comment <basefont> <bgsound> <link> <meta> <noframes>
          <style>
        run: |
          {{use '@in-head'}}
      - match: </br>
        run: |
          {{use 'anything-else'}}
      - match: <head> <noscript> </>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          {{use '$parse-error'}}
          debug_assert!(self.context().is_html_element(tag!(Noscript)));
          self.pop_element();
          debug_assert!(self.context().is_html_element(tag!(Head)));
          self.switch_to(mode!(InHead));
          Control::Reprocess

  - name: after-head
    ref: the-after-head-insertion-mode
    rules:
      - match: whitespace
        run: |
          self.append_char(c);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <body>
        run: |
          self.push_html_body_element(tag);
          self.frameset_ok = false;
          self.switch_to(mode!(InBody));
          Control::Continue
      - match: <frameset>
        run: |
          self.push_html_frameset_element(tag);
          self.switch_to(mode!(InFrameset));
          Control::Continue
      - match: >-
          <base> <basefont> <bgsound> <link> <meta> <noframes> <script> <style>
          <template> <title>
        run: |
          {{use '$parse-error'}}
          self.reopen_head_element();
          {{use '@in-head'}}
        pre_conditions:
          has_head_element_pointer: true
        post_conditions:
          has_head_element_pointer: true
      - match: </template>
        run: |
          {{use '@in-head'}}
      - match: </body> </html> </br>
        run: |
          {{use 'anything-else'}}
      - match: <head> </>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        id: anything-else
        run: |
          self.push_html_body_element(&Tag::with_no_attrs("body"));
          self.switch_to(mode!(InBody));
          Control::Reprocess

  - name: in-body
    ref: parsing-main-inbody
    rules:
      # Using `null` causes some issues.
      # So, we use `nul` as a simple solution.
      - match: nul
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: whitespace
        run: |
          self.reconstruct_active_formatting_elements();
          self.append_char(c);
          Control::Continue
      # character: !(null or whitespace)
      - match: character
        run: |
          self.reconstruct_active_formatting_elements();
          self.append_char(c);
          self.frameset_ok = false;
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '$parse-error'}}
          if self.context().has_template_element() {
              // Ignore the token.
          } else {
              self.set_attributes_to_html_element(tag);
          }
          Control::Continue
      - match: >-
          <base> <basefont> <bgsound> <link> <meta> <noframes> <script> <style>
          <template> <title> </template>
        run: |
          {{use '@in-head'}}
      - match: <body>
        run: |
          {{use '$parse-error'}}
          // TODO: Ignore the token (fragment case).
          self.frameset_ok = false;
          self.set_attributes_to_body_element(tag);
          Control::Continue
      - match: <frameset>
        run: |
          {{use '$parse-error'}}
          // TODO: Ignore the token (fragment case).
          if !self.frameset_ok {
              // Ignore the token.
          } else {
              while !self.context().is_html_element(tag!(Html)) {
                  self.remove_element();
              }
              self.push_html_frameset_element(tag);
              self.switch_to(mode!(InFrameset));
          }
          Control::Continue
      - match: eof
        run: |
          // TODO
          Control::Done
      - match: </body>
        run: |
          // TODO
          self.switch_to(mode!(AfterBody));
          Control::Continue
      - match: </html>
        run: |
          // TODO
          self.switch_to(mode!(AfterBody));
          Control::Reprocess
      - match: >-
          <address> <article> <aside> <blockquote> <center> <details> <dialog>
          <dir> <div> <dl> <fieldset> <figcaption> <figure> <footer> <header>
          <hgroup> <main> <menu> <nav> <ol> <p> <section> <summary> <ul>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <h1> <h2> <h3> <h4> <h5> <h6>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          if self.context().is_html_heading_element() {
              {{use '$parse-error'}}
              self.pop_element();
          }
          self.push_html_heading_element(tag);
          Control::Continue
      - match: <pre> <listing>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_{{tag_name}}_element(tag);
          self.ignore_lf = true;
          self.frameset_ok = false;
          Control::Continue
      - match: <form>
        run: |
          // TODO
          {{use 'any-other-start-tag'}}
      - match: <li>
        run: |
          self.frameset_ok = false;
          let mut context_pos = self.context_stack.len() - 1;
          loop {
              let context = &self.context_stack[context_pos];
              if context.is_html_element(tag!(Li)) {
                  self.close_implied_tags_except_for(tag!(Li));
                  if self.context().is_html_element(tag!(Li)) {
                      {{use '$parse-error'}}
                  }
                  while !self.context().is_html_element(tag!(Li)) {
                      self.pop_element();
                  }
                  self.pop_element(); // pop an html li element
                  break;
              }
              let local_name = context.local_name();
              if local_name.is_special() {
                  match local_name {
                      tag!(Address, Div, P) => (),
                      _ => break,
                  }
              }
              context_pos -= 1;
          }
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_li_element(tag);
          Control::Continue
      - match: <dd> <dt>
        run: |
          // TODO
          {{use 'any-other-start-tag'}}
      - match: <plaintext>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_plaintext_element(tag);
          Control::SwitchTo(InitialState::Plaintext, "plaintext")
      - match: <button>
        run: |
          if self.context().has_button_element_in_scope() {
              {{use '$parse-error'}}
              self.close_implied_tags();
              while !self.context().is_html_element(tag!(Button)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html button element
          }
          self.reconstruct_active_formatting_elements();
          self.push_html_button_element(tag);
          self.frameset_ok = false;
          Control::Continue
      - match: >-
          </address> </article> </aside> </blockquote> </button> </center>
          </details> </dialog> </dir> </div> </dl> </fieldset> </figcaption>
          </figure> </footer> </header> </hgroup> </listing> </main> </menu>
          </nav> </ol> </pre> </section> </summary> </ul>
        run: |
          if !self.context().has_{{tag_name}}_element_in_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!({{TagName}})) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html {{tag_name}} element
          }
          Control::Continue
      - match: </form>
        run: |
          // TODO
          if !self.context().has_form_element_in_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!(Form)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Form)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html form element
          }
          Control::Continue
      - match: </p>
        run: |
          if !self.context().has_p_element_in_button_scope() {
              {{use '$parse-error'}}
              self.push_html_p_element(&Tag::with_no_attrs("p"));
          }
          self.close_p_element();
          Control::Continue
      - match: </li>
        run: |
          if !self.context().has_li_element_in_list_item_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags_except_for(tag!(Li));
              if !self.context().is_html_element(tag!(Li)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Li)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html li element
          }
          Control::Continue
      - match: </dd> </dt>
        run: |
          if !self.context().has_{{tag_name}}_element_in_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags_except_for(tag!({{TagName}}));
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!({{TagName}})) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html {{tag_name}} element
          }
          Control::Continue
      - match: </h1> </h2> </h3> </h4> </h5> </h6>
        run: |
          if !self.context().has_heading_element_in_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_heading_element() {
                  self.pop_element();
              }
              self.pop_element(); // pop an html heading element
          }
          Control::Continue
      - match: </sarcasm>
        run: |
          // TODO: Take a deep breath.
          {{use 'any-other-end-tag'}}
      - match: <a>
        run: |
          if !self.context().has_a_element_in_active_formatting_elements() {
              {{use '$parse-error'}}
              self.perform_adoption_agency_algorithm(tag);
          }
          self.reconstruct_active_formatting_elements();
          self.push_html_a_element(tag);
          self.push_element_to_active_formatting_context();
          Control::Continue
      - match: >-
          <b> <big> <code> <em> <font> <i> <s> <small> <strike> <strong> <tt>
          <u>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          self.push_element_to_active_formatting_contexts();
          Control::Continue
      - match: <nobr>
        run: |
          self.reconstruct_active_formatting_elements();
          if self.context().has_nobr_element_in_scope() {
              {{use '$parse-error'}}
              self.perform_adoption_agency_algorithm(tag);
              self.reconstruct_active_formatting_elements();
          }
          self.push_html_nobr_element(tag);
          self.push_element_to_active_formatting_contexts();
          Control::Continue
      - match: >-
          </a> </b> </big> </code> </em> </font> </i> </nobr> </s> </small>
          </strike> </strong> </tt> </u>
        run: |
          self.perform_adoption_agency_algorithm(tag);
          Control::Continue
      - match: <applet> <marquee> <object>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          self.push_marker_to_active_formatting_contexts();
          self.frameset_ok = false;
          Control::Continue
      - match: </applet> </marquee> </object>
        run: |
          if !self.context().has_{{tag_name}}_element_in_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!({{TagName}})) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html {{tag_name}} element
              self.pop_active_formatting_element_up_to_marker();
          }
          Control::Continue
      - match: <table>
        run: |
          if self.quirks_mode != QuirksMode::Quirks {
              if self.context().has_p_element_in_button_scope() {
                  self.close_p_element();
              }
          }
          self.push_html_table_element(tag);
          self.frameset_ok = false;
          self.switch_to(mode!(InTable));
          Control::Continue
      - match: </br>
        run: |
          {{use '$parse-error'}}
          // TODO: Drop the attributes from the token.
          {{use 'start-br'}}
      - match: <area> <br> <embed> <img> <keygen> <wbr>
        id: start-br
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          self.pop_element();
          if tag.self_closing {
              // TODO: Acknowledge the token's self-closing flag
          }
          self.frameset_ok = false;
          Control::Continue
      - match: <input>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_input_element(tag);
          self.pop_element();
          if Self::is_visible_input(tag) {
              self.frameset_ok = false;
          }
          Control::Continue
      - match: <param> <source> <track>
        run: |
          self.push_html_{{tag_name}}_element(tag);
          self.pop_element();
          if tag.self_closing {
              // TODO: Acknowledge the token's self-closing flag
          }
          Control::Continue
      - match: <hr>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.push_html_hr_element(tag);
          self.pop_element();
          if tag.self_closing {
              // TODO: Acknowledge the token's self-closing flag
          }
          self.frameset_ok = false;
          Control::Continue
      - match: <image>
        run: |
          {{use '$parse-error'}}
          // TODO: Change the token's tag name to "img" and reprocess it.
          Control::Continue
      - match: <textarea>
        run: |
          self.push_html_textarea_element(tag);
          self.ignore_lf = true;
          self.frameset_ok = false;
          self.save_and_switch_to(mode!(Text));
          Control::SwitchTo(InitialState::Rcdata, "textarea")
      - match: <xmp>
        run: |
          if self.context().has_p_element_in_button_scope() {
              self.close_p_element();
          }
          self.reconstruct_active_formatting_elements();
          self.frameset_ok = false;
          {{use '$generic-raw-text-element-parsing-algorithm'}}
      - match: <iframe>
        run: |
          self.frameset_ok = false;
          {{use '$generic-raw-text-element-parsing-algorithm'}}
      - match: <noembed>
        run: |
          {{use '$generic-raw-text-element-parsing-algorithm'}}
      # The corresponding rule in the HTML5 specification is expressed with a
      # guard condition.  But we moves it into the `run` expression in order
      # to simplify the format of this YAML file.
      - match: <noscript>
        run: |
          if self.scripting {
              {{use '$generic-raw-text-element-parsing-algorithm'}}
          } else {
              {{use 'any-other-start-tag'}}
          }
      - match: <select>
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_select_element(tag);
          self.frameset_ok = false;
          self.switch_to(match self.mode {
              mode!(InTable, InCaption, InTableBody, InRow, InCell) => mode!(InSelectInTable),
              _ => mode!(InSelect),
          });
          Control::Continue
      - match: <optgroup> <option>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
          }
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <rb> <rtc>
        run: |
          if self.context().has_ruby_element_in_scope() {
              self.close_implied_tags();
          }
          if !self.context().is_html_element(tag!(Ruby)) {
              {{use '$parse-error'}}
          }
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <rp> <rt>
        run: |
          if self.context().has_ruby_element_in_scope() {
              self.close_implied_tags_except_for(tag!(Rtc));
          }
          if !self.context().is_one_of_html_elements(&tags![Ruby, Rtc]) {
              {{use '$parse-error'}}
          }
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: <math>
        run: |
          self.reconstruct_active_formatting_elements();
          // TODO: Adjust MathML attributes for the token. (This fixes the case of MathML attributes that are not all lowercase.)
          // TODO: Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink.)
          // TODO: Insert a foreign element for the token, in the MathML namespace.
          self.push_mathml_element(tag, tag!(Math));
          // TODO: If the token has its self-closing flag set, pop_element the current node off the stack of open elements and acknowledge the token's self-closing flag.
          if tag.self_closing {
              self.pop_element();
          }
          Control::Continue
      - match: <svg>
        run: |
          self.reconstruct_active_formatting_elements();
          // TODO: Adjust SVG attributes for the token. (This fixes the case of SVG attributes that are not all lowercase.)
          // TODO: Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink in SVG.)
          // TODO: Insert a foreign element for the token, in the SVG namespace.
          self.push_svg_element(tag, tag!(Svg));
          // TODO: If the token has its self-closing flag set, pop_element the current node off the stack of open elements and acknowledge the token's self-closing flag.
          if tag.self_closing {
              self.pop_element();
          }
          Control::Continue
      - match: >-
          <caption> <col> <colgroup> <frame> <head> <tbody> <td> <tfoot> <th>
          <thead> <tr>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <>
        id: any-other-start-tag
        run: |
          self.reconstruct_active_formatting_elements();
          self.push_html_{{tag_name}}_element(tag);
          Control::Continue
      - match: </>
        id: any-other-end-tag
        run: |
          self.append_text_if_exists();
          let mut context_pos = self.context_stack.len() - 1;
          loop {
              let context = &self.context_stack[context_pos];
              let element = context.open_element.node;
              if context.is_html() && self.inner.has_same_name(element, tag.name) {
                  self.close_implied_tags_except_for(tag!({{TagName}})); // TODO
                  if element != self.context().open_element.node {
                      // TODO: Parse error.
                  }
                  while self.context_stack.len() > context_pos {
                      self.pop_element();
                  }
                  break;
              } else {
                  if context.open_element.local_name.is_special() {
                      // TODO: Parse error.
                      // Ignore the token.
                      break;
                  }
              }
              context_pos -= 1;
          }
          Control::Continue

  - name: text
    ref: parsing-main-incdata
    rules:
      - match: nul whitespace character
        run: |
          self.append_char(c);
          Control::Continue
      - match: eof
        run: |
          {{use '$parse-error'}}
          if self.context().is_html_element(tag!(Script)) {
              // TODO: set its already started to true.
          }
          self.pop_element();
          self.switch_to_original_mode();
          Control::Reprocess
      - match: </script>
        run: |
          // TODO: If the active speculative HTML parser is null and the JavaScript execution context stack is empty, then perform a microtask checkpoint.
          self.pop_element();
          self.switch_to_original_mode();
          Control::ExecuteScript
      - match: </>
        run: |
          self.pop_element();
          self.switch_to_original_mode();
          Control::Continue

  - name: in-table
    ref: parsing-main-intable
    rules:
      - match: nul whitespace character
        run: |
          if self.context().is_one_of_html_elements(&tags![Table, Tbody, Template, Tfoot, Thead, Tr]) {
              // TODO: Let the pending table character tokens be an empty list of tokens.
              self.save_and_switch_to(mode!(InTableText));
              Control::Reprocess
          } else {
              {{use 'anything-else'}}
          }
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <caption>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_caption_element(tag);
          self.push_marker_to_active_formatting_contexts();
          self.switch_to(mode!(InCaption));
          Control::Continue
      - match: <colgroup>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_colgroup_element(tag);
          self.switch_to(mode!(InColumnGroup));
          Control::Continue
      - match: <col>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_colgroup_element(&Tag::with_no_attrs("colgroup"));
          self.switch_to(mode!(InColumnGroup));
          Control::Reprocess
      - match: <tbody> <tfoot> <thead>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_{{tag_name}}_element(tag);
          self.switch_to(mode!(InTableBody));
          Control::Continue
      - match: <td> <th> <tr>
        run: |
          self.clear_stack_back_to_table_context();
          self.push_html_tbody_element(&Tag::with_no_attrs("tbody"));
          self.switch_to(mode!(InTableBody));
          Control::Reprocess
      - match: <table>
        run: |
          {{use '$parse-error'}}
          // TODO: If the stack of open elements does not have a table element in table scope, ignore the token.
          // TODO: Otherwise
          // TODO: Pop elements from this stack until a table element has been popped from the stack.
          // TODO: Reset the insertion mode appropriately.
          // TODO: Reprocess the token.
          Control::Continue
      - match: </table>
        run: |
          if !self.context().has_table_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              while !self.context().is_html_element(tag!(Table)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html table element
              Control::Continue
          }
      - match: >-
          </body> </caption> </col> </colgroup> </html> </tbody> </td> </tfoot>
          </th> </thead> </tr>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <style> <script> <template> </template>
        run: |
          {{use '@in-head'}}
      - match: <input>
        run: |
          if Self::is_visible_input(tag) {
              {{use 'anything-else'}}
          } else {
              {{use '$parse-error'}}
              self.push_html_input_element(tag);
              self.pop_element();
              if tag.self_closing {
                  // TODO: Acknowledge the token's self-closing flag
              }
              Control::Continue
          }
      - match: <form>
        run: |
          {{use '$parse-error'}}
          // TODO: If there is a template element on the stack of open elements, or if the form element pointer is not null, ignore the token.
          // TODO: Otherwise
          self.push_html_form_element(tag);
          // TODO: set the form element pointer to point to the element created.
          self.pop_element();
          Control::Continue
      - match: eof
        run: |
          {{use '@in-body'}}
      - match: any
        id: anything-else
        run: |
          {{use '$parse-error'}}
          self.enable_foster_parenting();
          let ctrl = {
              {{use '@in-body'}}
          };
          self.disable_foster_parenting();
          ctrl

  - name: in-table-text
    ref: parsing-main-intabletext
    rules:
      - match: nul
        run: |
          {{use '$ignore-token'}}
      - match: whitespace character
        run: |
          self.append_char(c);
          Control::Continue
      - match: any
        run: |
          // TODO
          if !self.text.is_empty() {
              self.insert_text_to_foster_parent();
          }
          self.switch_to_original_mode();
          Control::Reprocess

  - name: in-caption
    ref: parsing-main-incaption
    rules:
      - match: </caption>
        run: |
          if !self.context().has_caption_element_in_table_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!(Caption)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Caption)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html caption element
              self.pop_active_formatting_elements_up_to_marker();
              self.switch_to(mode!(InTable));
          }
          Control::Continue
      - match: >-
          <caption> <col> <colgroup> <tbody> <td> <tfoot> <th> <thead> <tr>
          </table>
        run: |
          if !self.context().has_caption_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!(Caption)) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!(Caption)) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html caption element
              self.pop_active_formatting_elements_up_to_marker();
              self.switch_to(mode!(InTable));
              Control::Reprocess
          }
      - match: >-
          </body> </col> </colgroup> </html> </tbody> </td> </tfoot> </th>
          </thead> </tr>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        run: |
          {{use '@in-body'}}

  - name: in-column-group
    ref: parsing-main-incolgroup
    rules:
      - match: whitespace
        run: |
          self.append_char(c);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <col>
        run: |
          self.push_html_col_element(tag);
          self.pop_element();
          if tag.self_closing {
              // TODO: Acknowledge the token's self-closing flag
          }
          Control::Continue
      - match: </colgroup>
        run: |
          if self.context().is_html_element(tag!(Colgroup)) {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.pop_element();
              self.switch_to(mode!(InTable));
              Control::Continue
          }
      - match: </col>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <template> </template>
        run: |
          {{use '@in-head'}}
      - match: eof
        run: |
          {{use '@in-body'}}
      - match: any
        run: |
          if !self.context().is_html_element(tag!(Colgroup)) {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.pop_element();
              self.switch_to(mode!(InTable));
              Control::Reprocess
          }

  - name: in-table-body
    ref: parsing-main-intbody
    rules:
      - match: <tr>
        run: |
          self.clear_stack_back_to_table_body_context();
          self.push_html_tr_element(tag);
          self.switch_to(mode!(InRow));
          Control::Continue
      - match: <th> <td>
        run: |
          {{use '$parse-error'}}
          self.clear_stack_back_to_table_body_context();
          self.push_html_tr_element(&Tag::with_no_attrs("tr"));
          self.switch_to(mode!(InRow));
          Control::Reprocess
      - match: </tbody> </tfoot> </thead>
        run: |
          if !self.context().has_{{tag_name}}_element_in_table_scope() {
              {{use '$parse-error'}}
              // Ignore the token.
          } else {
              self.clear_stack_back_to_table_body_context();
              self.pop_element();
              self.switch_to(mode!(InTable));
          }
          Control::Continue
      - match: <caption> <col> <colgroup> <tbody> <tfoot> <thead> </table>
        run: |
          if !self.context().has_rowgroup_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.clear_stack_back_to_table_body_context();
              self.pop_element();
              self.switch_to(mode!(InTable));
              Control::Reprocess
          }
      - match: </body> </caption> </col> </colgroup> </html> </td> </th> </tr>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        run: |
          {{use '@in-table'}}

  - name: in-row
    ref: parsing-main-intr
    rules:
      - match: <th> <td>
        run: |
          self.clear_stack_back_to_table_row_context();
          self.push_html_{{tag_name}}_element(tag);
          self.push_marker_to_active_formatting_contexts();
          self.switch_to(mode!(InCell));
          Control::Continue
      - match: </tr>
        run: |
          if !self.context().has_tr_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.clear_stack_back_to_table_row_context();
              debug_assert!(self.context().is_html_element(tag!(Tr)));
              self.pop_element();
              self.switch_to(mode!(InTableBody));
              Control::Continue
          }
      - match: <caption> <col> <colgroup> <tbody> <tfoot> <thead> <tr> </table>
        run: |
          if !self.context().has_tr_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.clear_stack_back_to_table_row_context();
              debug_assert!(self.context().is_html_element(tag!(Tr)));
              self.pop_element();
              self.switch_to(mode!(InTableBody));
              Control::Reprocess
          }
      - match: </tbody> </tfoot> </thead>
        run: |
          if !self.context().has_{{tag_name}}_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else if !self.context().has_tr_element_in_table_scope() {
              {{use '$ignore-token'}}
          } else {
              self.clear_stack_back_to_table_row_context();
              debug_assert!(self.context().is_html_element(tag!(Tr)));
              self.pop_element();
              self.switch_to(mode!(InTableBody));
              Control::Reprocess
          }
      - match: </body> </caption> </col> </colgroup> </html> </td> </th>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: any
        run: |
          {{use '@in-table'}}

  - name: in-cell
    ref: parsing-main-intd
    rules:
      - match: </td> </th>
        run: |
          if !self.context().has_{{tag_name}}_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_implied_tags();
              if !self.context().is_html_element(tag!({{TagName}})) {
                  {{use '$parse-error'}}
              }
              while !self.context().is_html_element(tag!({{TagName}})) {
                  self.pop_element();
              }
              self.pop_element(); // pop an html {{tag_name}} element
              self.pop_active_formatting_elements_up_to_marker();
              self.switch_to(mode!(InRow));
              Control::Continue
          }
      - match: <caption> <col> <colgroup> <tbody> <td> <tfoot> <th> <thead> <tr>
        run: |
          if !self.context().has_cell_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_cell();
              Control::Reprocess
          }
      - match: </body> </caption> </col> </colgroup> </html>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: </table> </tbody> </tfoot> </thead> </tr>
        run: |
          if !self.context().has_{{tag_name}}_element_in_table_scope() {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.close_cell();
              Control::Reprocess
          }
      - match: any
        run: |
          {{use '@in-body'}}

  - name: in-select
    ref: parsing-main-inselect
    rules:
      - match: nul
        run: |
          {{use '$ignore-token'}}
      - match: whitespace character
        run: |
          self.append_char(c);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <option>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
          }
          self.push_html_option_element(tag);
          Control::Continue
      - match: <optgroup>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
          }
          if self.context().is_html_element(tag!(Optgroup)) {
              self.pop_element();
          }
          self.push_html_optgroup_element(tag);
          Control::Continue
      - match: </optgroup>
        run: |
          // TODO: First, if the current node is an option element, and the node immediately before it in the stack of open elements is an optgroup element, then pop the current node from the stack of open elements.
          if self.context().is_html_element(tag!(Optgroup)) {
              self.pop_element();
              Control::Continue
          } else {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          }
      - match: </option>
        run: |
          if self.context().is_html_element(tag!(Option)) {
              self.pop_element();
              Control::Continue
          } else {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          }
      - match: </select>
        run: |
          // TODO: If the stack of open elements does not have a select element in select scope, this is a parse error; ignore the token. (fragment case)
          while !self.context().is_html_element(tag!(Select)) {
              self.pop_element();
          }
          self.pop_element(); // pop an html select element
          self.reset_insertion_mode_appropriately();
          Control::Continue
      - match: <select>
        run: |
          {{use '$parse-error'}}
          // TODO: If the stack of open elements does not have a select element in select scope, ignore the token. (fragment case)
          while !self.context().is_html_element(tag!(Select)) {
              self.pop_element();
          }
          self.pop_element(); // pop an html select element
          self.reset_insertion_mode_appropriately();
          Control::Continue
      - match: <input> <keygen> <textarea>
        run: |
          {{use '$parse-error'}}
          // TODO: If the stack of open elements does not have a select element in select scope, ignore the token. (fragment case)
          while !self.context().is_html_element(tag!(Select)) {
              self.pop_element();
          }
          self.pop_element(); // pop an html select element
          self.reset_insertion_mode_appropriately();
          Control::Reprocess
      - match: <script> <template> </template>
        run: |
          {{use '@in-head'}}
      - match: eof
        run: |
          {{use '@in-body'}}
      - match: any
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}

  - name: in-select-in-table
    ref: parsing-main-inselectintable
    rules:
      - match: <caption> <table> <tbody> <tfoot> <thead> <tr> <td> <th>
        run: |
          {{use '$parse-error'}}
          while !self.context().is_html_element(tag!(Select)) {
              self.pop_element();
          }
          self.pop_element(); // pop an html select element
          self.reset_insertion_mode_appropriately();
          Control::Reprocess
      - match: </caption> </table> </tbody> </tfoot> </thead> </tr> </td> </th>
        run: |
          {{use '$parse-error'}}
          // TODO: If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then ignore the token.
          while !self.context().is_html_element(tag!(Select)) {
              self.pop_element();
          }
          self.pop_element(); // pop an html select element
          self.reset_insertion_mode_appropriately();
          Control::Reprocess
      - match: any
        run: |
          {{use '@in-select'}}

  - name: in-template
    ref: parsing-main-intemplate
    rules:
      - match: nul whitespace character comment doctype
        run: |
          {{use '@in-body'}}
      - match: >-
          <base> <basefont> <bgsound> <link> <meta> <noframes> <script> <style>
          <template> <title> </template>
        run: |
          {{use '@in-head'}}
      - match: <caption> <colgroup> <tbody> <tfoot> <thead>
        run: |
          // TODO: Pop the current template insertion mode off the stack of template insertion modes.
          // TODO: Push "in table" onto the stack of template insertion modes so that it is the new current template insertion mode.
          self.switch_to(mode!(InTable));
          Control::Reprocess
      - match: <col>
        run: |
          // TODO: Pop the current template insertion mode off the stack of template insertion modes.
          // TODO: Push "in column group" onto the stack of template insertion modes so that it is the new current template insertion mode.
          self.switch_to(mode!(InColumnGroup));
          Control::Reprocess
      - match: <tr>
        run: |
          // TODO: Pop the current template insertion mode off the stack of template insertion modes.
          // TODO: Push "in table body" onto the stack of template insertion modes so that it is the new current template insertion mode.
          self.switch_to(mode!(InTableBody));
          Control::Reprocess
      - match: <td> <th>
        run: |
          // TODO: Pop the current template insertion mode off the stack of template insertion modes.
          // TODO: Push "in row" onto the stack of template insertion modes so that it is the new current template insertion mode.
          self.switch_to(mode!(InRow));
          Control::Reprocess
      - match: <>
        run: |
          // TODO: Pop the current template insertion mode off the stack of template insertion modes.
          // TODO: Push "in body" onto the stack of template insertion modes so that it is the new current template insertion mode.
          self.switch_to(mode!(InBody));
          Control::Reprocess
      - match: </>
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: eof
        run: |
          // TODO
          Control::Done

  - name: after-body
    ref: parsing-main-afterbody
    rules:
      - match: whitespace
        run: |
          {{use '@in-body'}}
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: </html>
        run: |
          // TODO: If the parser was created as part of the HTML fragment parsing algorithm, this is a parse error; ignore the token. (fragment case)
          self.switch_to(mode!(AfterAfterBody));
          Control::Continue
      - match: eof
        run: |
          Control::Done
      - match: any
        run: |
          {{use '$parse-error'}}
          self.switch_to(mode!(InBody));
          Control::Reprocess

  - name: in-frameset
    ref: parsing-main-inframeset
    rules:
      - match: whitespace
        run: |
          self.append_char(c);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: <frameset>
        run: |
          self.push_html_frameset_element(tag);
          Control::Continue
      - match: </frameset>
        run: |
          if self.context().is_html_element(tag!(Html)) {
              {{use '$parse-error'}}
              {{use '$ignore-token'}}
          } else {
              self.pop_element();
              // TODO: If the parser was not created as part of the HTML fragment parsing algorithm (fragment case)
              if self.context().is_html_element(tag!(Frameset)) {
                  self.switch_to(mode!(AfterFrameset));
              }
              Control::Continue
          }
      - match: <frame>
        run: |
          self.push_html_frame_element(tag);
          self.pop_element();
          if tag.self_closing {
              // TODO: Acknowledge the token's self-closing flag
          }
          Control::Continue
      - match: <noframes>
        run: |
          {{use '@in-head'}}
      - match: eof
        run: |
          if !self.context().is_html_element(tag!(Html)) {
              {{use '$parse-error'}}
          }
          Control::Done
      - match: any
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}

  - name: after-frameset
    ref: parsing-main-afterframeset
    rules:
      - match: whitespace
        run: |
          self.append_char(c);
          Control::Continue
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}
      - match: <html>
        run: |
          {{use '@in-body'}}
      - match: </html>
        run: |
          self.switch_to(mode!(AfterAfterFrameset));
          Control::Continue
      - match: <noframes>
        run: |
          {{use '@in-head'}}
      - match: eof
        run: |
          Control::Done
      - match: any
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}

  - name: after-after-body
    ref: the-after-after-body-insertion-mode
    rules:
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype whitespace <html>
        run: |
          {{use '@in-body'}}
      - match: eof
        run: |
          Control::Done
      - match: any
        run: |
          {{use '$parse-error'}}
          self.switch_to(mode!(InBody));
          Control::Reprocess

  - name: after-after-frameset
    ref: the-after-after-frameset-insertion-mode
    rules:
      - match: comment
        run: |
          self.insert_comment(&comment);
          Control::Continue
      - match: doctype whitespace <html>
        run: |
          {{use '@in-body'}}
      - match: eof
        run: |
          Control::Done
      - match: <noframes>
        run: |
          {{use '@in-head'}}
      - match: any
        run: |
          {{use '$parse-error'}}
          {{use '$ignore-token'}}

# Code snippets that can be referred by `$<snipetts.name>` from `run`.
snippets:
  ignore-token:
    code: |
      // Ignore the token.
      Control::Continue
  parse-error:
    if: enable-parse-error
    code: |
      // TODO: Parse error.
  generic-rcdata-element-parsing-algorithm:
    code: |
      self.push_html_{{tag_name}}_element(tag);
      self.save_and_switch_to(mode!(Text));
      Control::SwitchTo(bee_htmltokenizer::InitialState::Rcdata, "{{tag_name}}")
  generic-raw-text-element-parsing-algorithm:
    code: |
      self.push_html_{{tag_name}}_element(tag);
      self.save_and_switch_to(mode!(Text));
      Control::SwitchTo(bee_htmltokenizer::InitialState::Rawtext, "{{tag_name}}")
