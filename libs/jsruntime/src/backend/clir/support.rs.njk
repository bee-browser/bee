// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{ template }}

use std::cell::OnceCell;

use cranelift::codegen::ir;
use cranelift_jit::JITBuilder;
use cranelift_module::FuncId;
use cranelift_module::Linkage;
use cranelift_module::Module;

use super::compiler;
use super::RuntimeFunctions;

// TODO(perf): using libm causes the following error in the coverage test w/ llvm-cov:
// "can't resolve symbol fmod"
extern "C" fn fmod(a: f64, b: f64) -> f64 {
    a % b
}

// TODO(perf): using libm causes the following error in the coverage test w/ llvm-cov:
// "can't resolve symbol pow"
extern "C" fn pow(a: f64, b: f64) -> f64 {
    a.powf(b)
}

pub fn register_symbols(builder: &mut JITBuilder, funcs: &RuntimeFunctions) {
    builder.symbol("fmod", fmod as *const u8);
    builder.symbol("pow", pow as *const u8);
    {%- for func in data.functions %}
    builder.symbol("runtime_{{ func.name }}", funcs.{{ func.name }} as *const u8);
    {%- endfor %}
}

#[derive(Clone)]
pub struct RuntimeFunctionIds {
    // TODO(feat): if cfg!(feature = "libm")
    pub fmod: FuncId,
    // TODO(feat): if cfg!(feature = "libm")
    pub pow: FuncId,

    {%- for func in data.functions %}
    #[allow(unused)]
    pub {{ func.name }}: FuncId,
    {%- endfor %}
}

pub fn make_lambda_signature(module: &mut impl Module) -> ir::Signature {
    let mut sig = module.make_signature();
    let addr_type = module.target_config().pointer_type();

    // runtime: *mut c_void
    sig.params.push(ir::AbiParam::new(addr_type));
    // context: *mut c_void
    sig.params.push(ir::AbiParam::new(addr_type));
    // this: *mut Value
    sig.params.push(ir::AbiParam::new(addr_type));
    // args: u16
    sig.params.push(ir::AbiParam::new(ir::types::I16));
    // argv: *mut Value
    sig.params.push(ir::AbiParam::new(addr_type));
    // retv: *mut Value
    sig.params.push(ir::AbiParam::new(addr_type));

    // #[repr(u32)] Status
    sig.returns.push(ir::AbiParam::new(ir::types::I32));

    sig
}

pub fn declare_functions(module: &mut impl Module) -> RuntimeFunctionIds {
    let addr_type = module.target_config().pointer_type();

    // TODO(feat): if cfg!(feature = "libm")
    let name = "fmod";
    let mut sig = module.make_signature();
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.returns.push(ir::AbiParam::new(ir::types::F64));
    let fmod = module.declare_function(name, Linkage::Import, &sig).unwrap();

    // TODO(feat): if cfg!(feature = "libm")
    let name = "pow";
    let mut sig = module.make_signature();
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.params.push(ir::AbiParam::new(ir::types::F64));
    sig.returns.push(ir::AbiParam::new(ir::types::F64));
    let pow = module.declare_function(name, Linkage::Import, &sig).unwrap();
    {%- for func in data.functions %}

    let name = "runtime_{{ func.name }}";
    let mut sig = module.make_signature();
    {%- for arg in func.args %}
    sig.params.push(ir::AbiParam::new({{ arg.clir_type }}));
    {%- endfor %}
    {%- if func.clir_ret %}
    sig.returns.push(ir::AbiParam::new({{ func.clir_ret }}));
    {%- endif %}
    let {{ func.name }} = module.declare_function(name, Linkage::Import, &sig).unwrap();
    {%- endfor %}

    RuntimeFunctionIds {
        fmod,
        pow,
        {%- for func in data.functions %}
        {{ func.name }},
        {%- endfor %}
    }
}

pub trait EditorSupport {
    // TODO(feat): if cfg!(feature = "libm")
    fn import_fmod(&mut self, func: &mut ir::Function) -> ir::FuncRef;
    // TODO(feat): if cfg!(feature = "libm")
    fn import_pow(&mut self, func: &mut ir::Function) -> ir::FuncRef;
    {%- for func in data.functions %}
    fn import_runtime_{{ func.name }}(&mut self, func: &mut ir::Function) -> ir::FuncRef;
    {%- endfor %}
}

impl EditorSupport for compiler::Session<'_> {
    fn import_fmod(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.executor.import_fmod(func)
    }

    fn import_pow(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.executor.import_pow(func)
    }
    {%- for func in data.functions %}

    fn import_runtime_{{ func.name }}(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.executor.import_runtime_{{ func.name }}(func)
    }
    {%- endfor %}
}

impl EditorSupport for crate::backend::clir::Executor {
    fn import_fmod(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.module.declare_func_in_func(self.runtime_func_ids.fmod, func)
    }

    fn import_pow(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.module.declare_func_in_func(self.runtime_func_ids.pow, func)
    }
    {%- for func in data.functions %}

    fn import_runtime_{{ func.name }}(&mut self, func: &mut ir::Function) -> ir::FuncRef {
        self.module.declare_func_in_func(self.runtime_func_ids.{{ func.name }}, func)
    }
    {%- endfor %}
}

#[derive(Default)]
pub struct RuntimeFunctionCache {
    // TODO(feat): if cfg!(feature = "libm")
    fmod: OnceCell<ir::FuncRef>,
    // TODO(feat): if cfg!(feature = "libm")
    pow: OnceCell<ir::FuncRef>,

    {%- for func in data.functions %}
    #[allow(unused)]
    {{ func.name }}: OnceCell<ir::FuncRef>,
    {%- endfor %}
}

impl RuntimeFunctionCache {
    // TODO(feat): if cfg!(feature = "libm")
    pub fn import_fmod(&self, support: &mut impl EditorSupport, func: &mut ir::Function) -> ir::FuncRef {
        *self.fmod.get_or_init(|| support.import_fmod(func))
    }

    // TODO(feat): if cfg!(feature = "libm")
    pub fn import_pow(&self, support: &mut impl EditorSupport, func: &mut ir::Function) -> ir::FuncRef {
        *self.pow.get_or_init(|| support.import_pow(func))
    }
    {%- for func in data.functions %}

    #[allow(unused)]
    pub fn import_runtime_{{ func.name }}(&self, support: &mut impl EditorSupport, func: &mut ir::Function) -> ir::FuncRef {
        *self.{{ func.name }}.get_or_init(|| support.import_runtime_{{ func.name }}(func))
    }
    {%- endfor %}
}
