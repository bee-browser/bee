// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: libs/jsruntime/src/bridge/llvmir/executor.codegen.cc.njk

#include "executor.hh"

#include <cmath>
#include <cstring>
#include <limits>

static llvm::ExitOnError ExitOnErr;

// TODO: link libm directly
extern "C" double runtime_fmod(double a, double b) {
  return std::fmod(a, b);
}

void Executor::RegisterRuntime(const Runtime* runtime) {
  llvm::orc::SymbolMap symbols;
  symbols[exec_session().intern("fmod")] = {
      llvm::orc::ExecutorAddr::fromPtr(runtime_fmod),
      llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("memcpy")] = {
      llvm::orc::ExecutorAddr::fromPtr(std::memcpy),
      llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("memset")] = {
      llvm::orc::ExecutorAddr::fromPtr(std::memset),
      llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("runtime_to_boolean")] = {
      llvm::orc::ExecutorAddr::fromPtr(runtime->to_boolean),
      llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("runtime_to_numeric")] = {
      llvm::orc::ExecutorAddr::fromPtr(runtime->to_numeric),
      llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("runtime_to_int32")] = {
      llvm::orc::ExecutorAddr::fromPtr(runtime->to_int32),
      llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("runtime_to_uint32")] = {
      llvm::orc::ExecutorAddr::fromPtr(runtime->to_uint32),
      llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("runtime_is_loosely_equal")] = {
      llvm::orc::ExecutorAddr::fromPtr(runtime->is_loosely_equal),
      llvm::JITSymbolFlags::Exported,
  };
  symbols[exec_session().intern("runtime_is_strictly_equal")] = {
      llvm::orc::ExecutorAddr::fromPtr(runtime->is_strictly_equal),
      llvm::JITSymbolFlags::Exported,
  };
  ExitOnErr(main_jd().define(llvm::orc::absoluteSymbols(std::move(symbols))));
}
