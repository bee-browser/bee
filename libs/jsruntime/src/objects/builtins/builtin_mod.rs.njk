// DO NOT EDIT THIS FILE BY HAND.
//
// This file was automagically generated with:
// template: {{ template }}

mod imp;

use jsparser::Symbol;

use crate::Runtime;
use crate::logger;
use crate::objects::ObjectHandle;
use crate::objects::Property;
use crate::types::CallContext;
use crate::types::Status;
use crate::types::Value;

use super::BuiltinFunctionParams;

impl<X> Runtime<X> {
    /// Returns `true` if `object` is a {{ data.metadata.class }} object.
    #[allow(unused)]
    pub(crate) fn is_{{ data.metadata.id }}_object(&self, object: ObjectHandle) -> bool {
        object.is_instance_of(self.{{ data.metadata.id }}_prototype)
    }

    /// Returns `true` if `value` holds a {{ data.metadata.class }} object.
    #[allow(unused)]
    pub(crate) fn value_is_{{ data.metadata.id }}_object(&self, value: &Value) -> bool {
        matches!(value, Value::Object(object) if self.is_{{ data.metadata.id }}_object(*object))
    }

    /// Creates the {{ data.metadata.class }} constructor.
    pub(super) fn create_{{ data.metadata.id }}_constructor(&mut self) -> ObjectHandle {
        logger::debug!(event = "create_{{ data.metadata.id }}_constructor");
        debug_assert!(self.{{ data.metadata.id }}_prototype.is_some());

        #[allow(unused_mut)]
        let mut constructor = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: constructor::<X>,
            name: const_string!("{{ data.metadata.class }}"),
            length: 1,
            slots: &[],
            prototype: self.{{ data.metadata.id }}_prototype,
        });

        {% for func in data.constructorProperties %}
        {% if func.kind == "constructor.function" %}
        let func = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: {{ func.imp }},
            name: const_string!("{{ func.name }}"),
            length: {{ func.length }},
            slots: &[],
            prototype: None,
        });
        let _ = constructor.define_own_property(Symbol::{{ func.symbol }}.into(), Property::data_wxc(Value::Object(func)));

        {% endif %}
        {% endfor %}
        // TODO(refactor): bind outside this function
        if let Some(mut prototype) = self.{{ data.metadata.id }}_prototype {
            let _ = prototype.define_own_property(Symbol::CONSTRUCTOR.into(), Property::data_wxc(Value::Object(constructor)));
        }

        constructor
    }

    /// Creates the {{ data.metadata.class }} prototype object.
    pub(super) fn create_{{ data.metadata.id }}_prototype(&mut self) -> ObjectHandle {
        logger::debug!(event = "creater_{{ data.metadata.id }}_prototype");
        debug_assert!(self.object_prototype.is_some());
        debug_assert!(self.function_prototype.is_some());

        #[allow(unused_mut)]
        let mut prototype = self.create_object(self.object_prototype);

        {% for prop in data.prototypeProperties %}
        {% if prop.kind == "prototype.property" %}
        imp::{{ prop.imp }}(self, prototype);

        {% elif prop.kind == "prototype.function" %}
        let func = self.create_builtin_function(&BuiltinFunctionParams {
            lambda: {{ prop.imp }},
            name: const_string!("{{ func.name }}"),
            length: {{ prop.length }},
            slots: &[],
            prototype: None,
        });
        let _ = prototype.define_own_property(Symbol::{{ prop.symbol }}.into(), Property::data_wxc(Value::Object(func)));

        {% endif %}
        {% endfor %}
        prototype
    }
}

// lambda functions
// TODO: use proc-macro

extern "C" fn constructor<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::constructor(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{% for func in data.constructorProperties %}
{% if func.kind == "constructor.function" %}

extern "C" fn {{ func.imp }}<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::{{ func.imp }}(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{% endif %}
{% endfor %}
{% for func in data.prototypeProperties %}
{% if func.kind == "prototype.function" %}

extern "C" fn {{ func.imp }}<X>(
    runtime: &mut Runtime<X>,
    context: &mut CallContext,
    retv: &mut Value,
) -> Status {
    match imp::{{ func.imp }}(runtime, context) {
        Ok(value) => {
            *retv = value;
            Status::Normal
        }
        Err(err) => {
            *retv = runtime.create_exception(err);
            Status::Exception
        }
    }
}
{% endif %}
{% endfor %}
